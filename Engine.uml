<?xml version="1.0" encoding="UTF-8"?>
<xmi:XMI xmi:version="20131001" xmlns:xmi="http://www.omg.org/spec/XMI/20131001" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:ActionLanguage="http://www.omg.org/spec/ALF/20120827/ActionLanguage-Profile" xmlns:RTCppProperties="http://www.eclipse.org/papyrus/umlrt/cppproperties" xmlns:UMLRTStateMachines="http://www.eclipse.org/papyrus/umlrt/statemachine" xmlns:UMLRealTime="http://www.eclipse.org/papyrus/umlrt" xmlns:ecore="http://www.eclipse.org/emf/2002/Ecore" xmlns:uml="http://www.eclipse.org/uml2/5.0.0/UML" xsi:schemaLocation="http://www.omg.org/spec/ALF/20120827/ActionLanguage-Profile pathmap://PAPYRUS_ACTIONLANGUAGE_PROFILE/ActionLanguage-Profile.profile.uml#_Kv8EIKFXEeS_KNX0nfvIVQ">
  <uml:Model xmi:id="_g0QecDbLEeeS0ZUearuafA" name="Engine">
    <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_g0QecTbLEeeS0ZUearuafA" source="http://www.eclipse.org/papyrus-rt/language/1.0.0">
      <details xmi:type="ecore:EStringToStringMapEntry" xmi:id="_g0QecjbLEeeS0ZUearuafA" key="language" value="umlrt-cpp"/>
    </eAnnotations>
    <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_TRuPYDphEeeXjLrCUGhTRw" source="UMLRT_Default_top">
      <details xmi:type="ecore:EStringToStringMapEntry" xmi:id="_TRx5wDphEeeXjLrCUGhTRw" key="top_name" value="Top"/>
    </eAnnotations>
    <packagedElement xmi:type="uml:Package" xmi:id="_EpgTwDmbEeetSfDhTP5ZLQ" name="Directions">
      <packagedElement xmi:type="uml:Collaboration" xmi:id="_EpeekDmbEeetSfDhTP5ZLQ" name="Directions">
        <interfaceRealization xmi:type="uml:InterfaceRealization" xmi:id="_EpiwATmbEeetSfDhTP5ZLQ" client="_EpeekDmbEeetSfDhTP5ZLQ" supplier="_Ephh4DmbEeetSfDhTP5ZLQ" contract="_Ephh4DmbEeetSfDhTP5ZLQ"/>
        <interfaceRealization xmi:type="uml:InterfaceRealization" xmi:id="_EpmaYDmbEeetSfDhTP5ZLQ" client="_EpeekDmbEeetSfDhTP5ZLQ" supplier="_EplMQDmbEeetSfDhTP5ZLQ" contract="_EplMQDmbEeetSfDhTP5ZLQ"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Interface" xmi:id="_Ephh4DmbEeetSfDhTP5ZLQ" name="Directions">
        <ownedOperation xmi:type="uml:Operation" xmi:id="_c25r4DmbEeetSfDhTP5ZLQ" name="directionsCalc">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_BxtKwDmcEeetSfDhTP5ZLQ" name="X">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_Bxw1IDmcEeetSfDhTP5ZLQ" name="Y">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_Ok3sgDwTEeez78_2BqgPcw" name="Direction">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="_KBqR8DwREeez78_2BqgPcw" name="directions">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_kUjW8DwREeez78_2BqgPcw" name="Direction">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="_VNDTgDvpEeePyrL5fVHxNw" name="exits"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Interface" xmi:id="_EpjXEDmbEeetSfDhTP5ZLQ" name="Directions~">
        <ownedOperation xmi:type="uml:Operation" xmi:id="_PyhPkDmbEeetSfDhTP5ZLQ" name="directionCalc">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_88fIQDmbEeetSfDhTP5ZLQ" name="X">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_-UbLkDmbEeetSfDhTP5ZLQ" name="Y">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="_IytLgDwREeez78_2BqgPcw" name="direction">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_kK9WEDwREeez78_2BqgPcw" name="Direction">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="_XB7KcDvpEeePyrL5fVHxNw" name="exit"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Usage" xmi:id="_EpklMDmbEeetSfDhTP5ZLQ" client="_EpeekDmbEeetSfDhTP5ZLQ" supplier="_EpjXEDmbEeetSfDhTP5ZLQ"/>
      <packagedElement xmi:type="uml:AnyReceiveEvent" xmi:id="_EpklMTmbEeetSfDhTP5ZLQ" name="*"/>
      <packagedElement xmi:type="uml:Interface" xmi:id="_EplMQDmbEeetSfDhTP5ZLQ" name="DirectionsIO"/>
      <packagedElement xmi:type="uml:Usage" xmi:id="_EpmaYTmbEeetSfDhTP5ZLQ" client="_EpeekDmbEeetSfDhTP5ZLQ" supplier="_EplMQDmbEeetSfDhTP5ZLQ"/>
      <packagedElement xmi:type="uml:CallEvent" xmi:id="_Pyh2oDmbEeetSfDhTP5ZLQ" operation="_PyhPkDmbEeetSfDhTP5ZLQ"/>
      <packagedElement xmi:type="uml:CallEvent" xmi:id="_c26S8DmbEeetSfDhTP5ZLQ" operation="_c25r4DmbEeetSfDhTP5ZLQ"/>
      <packagedElement xmi:type="uml:CallEvent" xmi:id="_VNEhoDvpEeePyrL5fVHxNw" operation="_VNDTgDvpEeePyrL5fVHxNw"/>
      <packagedElement xmi:type="uml:CallEvent" xmi:id="_XB7xgDvpEeePyrL5fVHxNw" operation="_XB7KcDvpEeePyrL5fVHxNw"/>
      <packagedElement xmi:type="uml:CallEvent" xmi:id="_IyvnwDwREeez78_2BqgPcw" operation="_IytLgDwREeez78_2BqgPcw"/>
      <packagedElement xmi:type="uml:CallEvent" xmi:id="_KBsHIDwREeez78_2BqgPcw" operation="_KBqR8DwREeez78_2BqgPcw"/>
    </packagedElement>
    <packagedElement xmi:type="uml:Package" xmi:id="_NBRMkDvjEeePyrL5fVHxNw" name="Status">
      <packagedElement xmi:type="uml:Collaboration" xmi:id="_NBM7IDvjEeePyrL5fVHxNw" name="Status">
        <interfaceRealization xmi:type="uml:InterfaceRealization" xmi:id="_NBeA4DvjEeePyrL5fVHxNw" client="_NBM7IDvjEeePyrL5fVHxNw" supplier="_NBZIYDvjEeePyrL5fVHxNw" contract="_NBZIYDvjEeePyrL5fVHxNw"/>
        <interfaceRealization xmi:type="uml:InterfaceRealization" xmi:id="_NBnx4DvjEeePyrL5fVHxNw" client="_NBM7IDvjEeePyrL5fVHxNw" supplier="_NBkHgDvjEeePyrL5fVHxNw" contract="_NBkHgDvjEeePyrL5fVHxNw"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Interface" xmi:id="_NBZIYDvjEeePyrL5fVHxNw" name="Status">
        <ownedOperation xmi:type="uml:Operation" xmi:id="_Wp5TsDvjEeePyrL5fVHxNw" name="isStartIn"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="_QT6MkDvkEeePyrL5fVHxNw" name="isReadyIn">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_rLS6MDvuEeePyrL5fVHxNw" name="X">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_rcJZoDvuEeePyrL5fVHxNw" name="Y">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
        </ownedOperation>
      </packagedElement>
      <packagedElement xmi:type="uml:Interface" xmi:id="_NBf2EDvjEeePyrL5fVHxNw" name="Status~">
        <ownedOperation xmi:type="uml:Operation" xmi:id="_UHUpQDvjEeePyrL5fVHxNw" name="isStartOut">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_fSRqgGfwEee-Kre0NmQF5w" name="X">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_g1hl8GfwEee-Kre0NmQF5w" name="Y">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="_O4c7MDvkEeePyrL5fVHxNw" name="isReadyOut">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_aW3bEDvrEeePyrL5fVHxNw" name="X">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_cXLtADvrEeePyrL5fVHxNw" name="Y">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="_ri_N0HFqEeepH5jGTij4Cg" name="zombieOut" visibility="public">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_ucGI8HFqEeepH5jGTij4Cg" name="data" type="_ONiHkHuuEee7RKzKc_Azzg"/>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_WhB84HbOEeeXs9sY7gI7cA" name="max">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
        </ownedOperation>
      </packagedElement>
      <packagedElement xmi:type="uml:Usage" xmi:id="_NBiSUDvjEeePyrL5fVHxNw" client="_NBM7IDvjEeePyrL5fVHxNw" supplier="_NBf2EDvjEeePyrL5fVHxNw"/>
      <packagedElement xmi:type="uml:AnyReceiveEvent" xmi:id="_NBiSUTvjEeePyrL5fVHxNw" name="*"/>
      <packagedElement xmi:type="uml:Interface" xmi:id="_NBkHgDvjEeePyrL5fVHxNw" name="StatusIO"/>
      <packagedElement xmi:type="uml:Usage" xmi:id="_NBoY8DvjEeePyrL5fVHxNw" client="_NBM7IDvjEeePyrL5fVHxNw" supplier="_NBkHgDvjEeePyrL5fVHxNw"/>
      <packagedElement xmi:type="uml:CallEvent" xmi:id="_UHWecDvjEeePyrL5fVHxNw" operation="_UHUpQDvjEeePyrL5fVHxNw"/>
      <packagedElement xmi:type="uml:CallEvent" xmi:id="_Wp6h0DvjEeePyrL5fVHxNw" operation="_Wp5TsDvjEeePyrL5fVHxNw"/>
      <packagedElement xmi:type="uml:CallEvent" xmi:id="_O4eJUDvkEeePyrL5fVHxNw" operation="_O4c7MDvkEeePyrL5fVHxNw"/>
      <packagedElement xmi:type="uml:CallEvent" xmi:id="_QT6zoDvkEeePyrL5fVHxNw" operation="_QT6MkDvkEeePyrL5fVHxNw"/>
      <packagedElement xmi:type="uml:CallEvent" xmi:id="_rjK0AHFqEeepH5jGTij4Cg" operation="_ri_N0HFqEeepH5jGTij4Cg"/>
    </packagedElement>
    <packagedElement xmi:type="uml:Class" xmi:id="_B6RyMDbOEeeS0ZUearuafA" name="Top" isActive="true">
      <ownedAttribute xmi:type="uml:Property" xmi:id="_SQAVkDliEeeHA4oSpVV8Ow" name="test" visibility="protected" type="_9yzxEDbOEeeS0ZUearuafA" isOrdered="true" aggregation="composite"/>
      <ownedAttribute xmi:type="uml:Property" xmi:id="___ZaUDs1Eee4vrzjGIvOwQ" name="testCont" visibility="protected" type="__7sO4DmcEeetSfDhTP5ZLQ" isOrdered="true" aggregation="composite"/>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_hV01cDvkEeePyrL5fVHxNw" name="calculation" visibility="protected" type="_LFgVYDvhEeePyrL5fVHxNw" isOrdered="true" aggregation="composite"/>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_0JZCIDvkEeePyrL5fVHxNw" name="detection" visibility="protected" type="_JK_5IDs0Eee4vrzjGIvOwQ" isOrdered="true" aggregation="composite"/>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_tk-VoHb6EeeKIIc_475P2A" name="zombieBehavior" visibility="protected" type="_FQa0MHL-EeeXs9sY7gI7cA" isOrdered="true" aggregation="composite"/>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_nnMvkHovEeesmeF6iS6c6Q" name="observer" visibility="protected" type="_fE_eAHovEeesmeF6iS6c6Q" isOrdered="true" aggregation="composite"/>
      <ownedConnector xmi:type="uml:Connector" xmi:id="_vFI2kDwPEeez78_2BqgPcw" name="RTConnector7">
        <end xmi:type="uml:ConnectorEnd" xmi:id="_vFLS0DwPEeez78_2BqgPcw" partWithPort="___ZaUDs1Eee4vrzjGIvOwQ" role="_qi3lQDwPEeez78_2BqgPcw"/>
        <end xmi:type="uml:ConnectorEnd" xmi:id="_vFMg8DwPEeez78_2BqgPcw" partWithPort="_hV01cDvkEeePyrL5fVHxNw" role="_s71WoDvhEeePyrL5fVHxNw"/>
      </ownedConnector>
      <ownedConnector xmi:type="uml:Connector" xmi:id="_oJDrwEAhEeecSdgC5rjddw" name="RTConnector8">
        <end xmi:type="uml:ConnectorEnd" xmi:id="_oJOq4EAhEeecSdgC5rjddw" partWithPort="_0JZCIDvkEeePyrL5fVHxNw" role="_HBMhgDvYEeeVBItGYDMaLQ"/>
        <end xmi:type="uml:ConnectorEnd" xmi:id="_oJP5AEAhEeecSdgC5rjddw" partWithPort="___ZaUDs1Eee4vrzjGIvOwQ" role="_BJxSwDvmEeePyrL5fVHxNw"/>
      </ownedConnector>
      <ownedConnector xmi:type="uml:Connector" xmi:id="_Od3XYETsEeem9u7KRr3TyA" name="RTConnector9">
        <end xmi:type="uml:ConnectorEnd" xmi:id="_Or-E0ETsEeem9u7KRr3TyA" partWithPort="_SQAVkDliEeeHA4oSpVV8Ow" role="_wEmS4ETrEeem9u7KRr3TyA"/>
        <end xmi:type="uml:ConnectorEnd" xmi:id="_Or-E0UTsEeem9u7KRr3TyA" partWithPort="_hV01cDvkEeePyrL5fVHxNw" role="_s58_8DvkEeePyrL5fVHxNw"/>
      </ownedConnector>
      <ownedConnector xmi:type="uml:Connector" xmi:id="_I8p4cHb7EeeKIIc_475P2A" name="RTConnector10">
        <end xmi:type="uml:ConnectorEnd" xmi:id="_I8rtoHb7EeeKIIc_475P2A" partWithPort="_tk-VoHb6EeeKIIc_475P2A" role="_yYpdoHbGEeeXs9sY7gI7cA"/>
        <end xmi:type="uml:ConnectorEnd" xmi:id="_I8sUsHb7EeeKIIc_475P2A" partWithPort="_hV01cDvkEeePyrL5fVHxNw" role="_57VOUHb6EeeKIIc_475P2A"/>
      </ownedConnector>
      <ownedConnector xmi:type="uml:Connector" xmi:id="_JzNF8Hb7EeeKIIc_475P2A" name="RTConnector11">
        <end xmi:type="uml:ConnectorEnd" xmi:id="_JzO7IHb7EeeKIIc_475P2A" partWithPort="_tk-VoHb6EeeKIIc_475P2A" role="_vEaVoHbaEeeXs9sY7gI7cA"/>
        <end xmi:type="uml:ConnectorEnd" xmi:id="_JzO7IXb7EeeKIIc_475P2A" partWithPort="_hV01cDvkEeePyrL5fVHxNw" role="_7pOTgHb6EeeKIIc_475P2A"/>
      </ownedConnector>
    </packagedElement>
    <packagedElement xmi:type="uml:Class" xmi:id="_9yzxEDbOEeeS0ZUearuafA" name="PreExecute" classifierBehavior="_cOGO0DbPEeeS0ZUearuafA" isActive="true">
      <ownedAttribute xmi:type="uml:Port" xmi:id="_XtyFUDbPEeeS0ZUearuafA" name="log" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
        <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6kIb0IeXEeSVyrlWP4nYew"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_lIhCgDeHEee0Cb7xo9L6qw" name="test" visibility="public" type="_NBM7IDvjEeePyrL5fVHxNw" isOrdered="true" aggregation="composite" isBehavior="true" isConjugated="true">
        <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_RVEasDv8EeePyrL5fVHxNw" value="2"/>
        <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_RVRPADv8EeePyrL5fVHxNw" value="2"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_UouR8EAcEeecSdgC5rjddw" name="directions" visibility="protected" type="_EpeekDmbEeetSfDhTP5ZLQ" isOrdered="true" aggregation="composite" isBehavior="true" isConjugated="true" isService="false"/>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_wEmS4ETrEeem9u7KRr3TyA" name="test2" visibility="public" type="_NBM7IDvjEeePyrL5fVHxNw" isOrdered="true" aggregation="composite" isBehavior="true" isConjugated="true"/>
      <ownedBehavior xmi:type="uml:StateMachine" xmi:id="_cOGO0DbPEeeS0ZUearuafA" name="Premake" isAbstract="true" isReentrant="false">
        <region xmi:type="uml:Region" xmi:id="_cO45ADbPEeeS0ZUearuafA" name="Region">
          <transition xmi:type="uml:Transition" xmi:id="_cPiZQDbPEeeS0ZUearuafA" name="Initial" source="_cPCC8DbPEeeS0ZUearuafA" target="_cPUW0DbPEeeS0ZUearuafA">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_1E_XMDeQEee0Cb7xo9L6qw" name="Effect" isReentrant="false">
              <language>C++</language>
              <body>    test2.isStartIn().send();
</body>
            </effect>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_cVZCsEAcEeecSdgC5rjddw" name="" source="_Kep4UDmSEeetSfDhTP5ZLQ" target="_ZzlNQEAcEeecSdgC5rjddw">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_cmESQEn8EeedZqJ4_o8GcQ" name="Effect" isReentrant="false">
              <language>C++</language>
              <body></body>
            </effect>
            <trigger xmi:type="uml:Trigger" xmi:id="_nKaPAEAdEeecSdgC5rjddw" event="_XB7xgDvpEeePyrL5fVHxNw" port="_UouR8EAcEeecSdgC5rjddw"/>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_RIBjkGf2Eee-Kre0NmQF5w" name="" source="_cPUW0DbPEeeS0ZUearuafA" target="_Kep4UDmSEeetSfDhTP5ZLQ">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_ZXZYwGf2Eee-Kre0NmQF5w" name="Effect" isReentrant="false">
              <language>C++</language>
              <body>log.log(&quot;Pre-execution done&quot;);&#xD;
test.isReadyIn(X,Y).send();</body>
            </effect>
            <trigger xmi:type="uml:Trigger" xmi:id="_ReF6MGf2Eee-Kre0NmQF5w" event="_UHWecDvjEeePyrL5fVHxNw" port="_wEmS4ETrEeem9u7KRr3TyA"/>
          </transition>
          <subvertex xmi:type="uml:Pseudostate" xmi:id="_cPCC8DbPEeeS0ZUearuafA" name=""/>
          <subvertex xmi:type="uml:State" xmi:id="_cPUW0DbPEeeS0ZUearuafA" name="Waiting">
            <ownedComment xmi:type="uml:Comment" xmi:id="_y-eQ0Et_EeeD4eyKVO2S_Q">
              <body>   ~~</body>
            </ownedComment>
            <entry xmi:type="uml:OpaqueBehavior" xmi:id="_tKzd8DeHEee0Cb7xo9L6qw" name="Entry" isReentrant="false">
              <language>C++</language>
              <body></body>
            </entry>
            <exit xmi:type="uml:OpaqueBehavior" xmi:id="__4M6cEoNEeedZqJ4_o8GcQ" name="Exit" isReentrant="false">
              <language>C++</language>
              <body></body>
            </exit>
          </subvertex>
          <subvertex xmi:type="uml:State" xmi:id="_Kep4UDmSEeetSfDhTP5ZLQ" name="Found">
            <entry xmi:type="uml:OpaqueBehavior" xmi:id="_P-T6wDmZEeetSfDhTP5ZLQ" name="Entry" isReentrant="false">
              <language>C++</language>
              <body></body>
            </entry>
          </subvertex>
          <subvertex xmi:type="uml:State" xmi:id="_ZzlNQEAcEeecSdgC5rjddw" name="Exited">
            <entry xmi:type="uml:OpaqueBehavior" xmi:id="_nZVnkEn8EeedZqJ4_o8GcQ" name="Entry" isReentrant="false">
              <language>C++</language>
              <body></body>
            </entry>
          </subvertex>
        </region>
      </ownedBehavior>
    </packagedElement>
    <packagedElement xmi:type="uml:Class" xmi:id="__7sO4DmcEeetSfDhTP5ZLQ" name="Running" classifierBehavior="_HTMHMDppEeehJIRyir005Q" isActive="true">
      <ownedAttribute xmi:type="uml:Port" xmi:id="_BJxSwDvmEeePyrL5fVHxNw" name="directions" visibility="public" type="_EpeekDmbEeetSfDhTP5ZLQ" isOrdered="true" aggregation="composite" isBehavior="true"/>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_MRDJMDvmEeePyrL5fVHxNw" name="log" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
        <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6kIb0IeXEeSVyrlWP4nYew"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_ozUTADvqEeePyrL5fVHxNw" name="x" visibility="private">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_ozUTATvqEeePyrL5fVHxNw" value="0"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_pF7F8DvqEeePyrL5fVHxNw" name="y" visibility="private">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_pF7F8TvqEeePyrL5fVHxNw" value="0"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_17g4UDvqEeePyrL5fVHxNw" name="test" visibility="protected" type="_NBM7IDvjEeePyrL5fVHxNw" isOrdered="true" aggregation="composite" isBehavior="true" isService="false"/>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_qi3lQDwPEeez78_2BqgPcw" name="directions2" visibility="public" type="_EpeekDmbEeetSfDhTP5ZLQ" isOrdered="true" aggregation="composite" isBehavior="true" isConjugated="true"/>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_144V8EAaEeecSdgC5rjddw" name="directions3" visibility="public" type="_EpeekDmbEeetSfDhTP5ZLQ" isOrdered="true" aggregation="composite" isBehavior="true">
        <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_fkrzwEAdEeecSdgC5rjddw" value="2"/>
        <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_fl8YAEAdEeecSdgC5rjddw" value="2"/>
      </ownedAttribute>
      <ownedBehavior xmi:type="uml:StateMachine" xmi:id="_HTMHMDppEeehJIRyir005Q" name="TestContStateMachine" isReentrant="false">
        <region xmi:type="uml:Region" xmi:id="_HTUDADppEeehJIRyir005Q" name="Region">
          <transition xmi:type="uml:Transition" xmi:id="_HTd0ADppEeehJIRyir005Q" name="Initial" source="_HTXtYDppEeehJIRyir005Q" target="_HTb-0DppEeehJIRyir005Q">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_eK0CIETQEeem9u7KRr3TyA" name="Effect" isReentrant="false">
              <language>C++</language>
              <body></body>
            </effect>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_TWvf4DvuEeePyrL5fVHxNw" name="" source="_evMisDvqEeePyrL5fVHxNw" target="_5YWi4GftEee-Kre0NmQF5w">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_GQdwsDvvEeePyrL5fVHxNw" name="Effect" isReentrant="false">
              <language>C++</language>
              <body>directions2.directionsCalc(x,y,Direction).send();</body>
            </effect>
            <trigger xmi:type="uml:Trigger" xmi:id="_M_IIoDwREeez78_2BqgPcw" event="_KBsHIDwREeez78_2BqgPcw" port="_BJxSwDvmEeePyrL5fVHxNw"/>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_Y7u9ADvvEeePyrL5fVHxNw" name="" source="_evMisDvqEeePyrL5fVHxNw" target="_T7QswDvvEeePyrL5fVHxNw">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_NuN98EAcEeecSdgC5rjddw" name="Effect" isReentrant="false">
              <language>C++</language>
              <body>directions3.exit().send();</body>
            </effect>
            <trigger xmi:type="uml:Trigger" xmi:id="_CHo1AEAfEeecSdgC5rjddw" event="_VNEhoDvpEeePyrL5fVHxNw" port="_BJxSwDvmEeePyrL5fVHxNw"/>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_xS6FwGftEee-Kre0NmQF5w" name="" source="_HTb-0DppEeehJIRyir005Q" target="_evMisDvqEeePyrL5fVHxNw">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_2_qNMGftEee-Kre0NmQF5w" name="Effect" isReentrant="false">
              <language>C++</language>
              <body>    x = X;
    y = Y;
</body>
            </effect>
            <trigger xmi:type="uml:Trigger" xmi:id="_0ob3IGftEee-Kre0NmQF5w" event="_QT6zoDvkEeePyrL5fVHxNw" port="_17g4UDvqEeePyrL5fVHxNw"/>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_Ojfq8GfuEee-Kre0NmQF5w" name="" source="_5YWi4GftEee-Kre0NmQF5w" target="_evMisDvqEeePyrL5fVHxNw">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_CAlukGfvEee-Kre0NmQF5w" name="Effect" isReentrant="false">
              <language>C++</language>
              <body>x = X;
y = Y;

</body>
            </effect>
            <trigger xmi:type="uml:Trigger" xmi:id="_OuDpQGf7Eee-Kre0NmQF5w" event="_Pyh2oDmbEeetSfDhTP5ZLQ" port="_qi3lQDwPEeez78_2BqgPcw"/>
          </transition>
          <subvertex xmi:type="uml:Pseudostate" xmi:id="_HTXtYDppEeehJIRyir005Q" name=""/>
          <subvertex xmi:type="uml:State" xmi:id="_HTb-0DppEeehJIRyir005Q" name="Waiting">
            <entry xmi:type="uml:OpaqueBehavior" xmi:id="_ggA-8ETQEeem9u7KRr3TyA" name="Entry" isReentrant="false">
              <language>C++</language>
              <body></body>
            </entry>
          </subvertex>
          <subvertex xmi:type="uml:State" xmi:id="_evMisDvqEeePyrL5fVHxNw" name="Playing">
            <entry xmi:type="uml:OpaqueBehavior" xmi:id="_OiIE4DvvEeePyrL5fVHxNw" name="Entry" isReentrant="false">
              <language>C++</language>
              <body></body>
            </entry>
          </subvertex>
          <subvertex xmi:type="uml:State" xmi:id="_T7QswDvvEeePyrL5fVHxNw" name="Finished">
            <entry xmi:type="uml:OpaqueBehavior" xmi:id="_rA9dADvvEeePyrL5fVHxNw" name="Entry" isReentrant="false">
              <language>C++</language>
              <body>log.log(&quot;Game Exited&quot;);
</body>
            </entry>
          </subvertex>
          <subvertex xmi:type="uml:State" xmi:id="_5YWi4GftEee-Kre0NmQF5w" name="checkingDirection"/>
        </region>
      </ownedBehavior>
    </packagedElement>
    <packagedElement xmi:type="uml:Class" xmi:id="_JK_5IDs0Eee4vrzjGIvOwQ" name="Detection" classifierBehavior="_Q9xfYDvYEeeVBItGYDMaLQ" isActive="true">
      <ownedAttribute xmi:type="uml:Port" xmi:id="_HBMhgDvYEeeVBItGYDMaLQ" name="directions" visibility="public" type="_EpeekDmbEeetSfDhTP5ZLQ" isOrdered="true" aggregation="composite" isBehavior="true" isConjugated="true"/>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_JOth8DvYEeeVBItGYDMaLQ" name="log" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
        <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6kIb0IeXEeSVyrlWP4nYew"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_raos0DvlEeePyrL5fVHxNw" name="test" visibility="protected" type="_NBM7IDvjEeePyrL5fVHxNw" isOrdered="true" aggregation="composite" isBehavior="true" isService="false"/>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_6dr5kDzHEeeY-4ihoO8v0Q" name="ESC_KEY" visibility="private">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_YokuYDzJEeeY-4ihoO8v0Q" value="27"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_Oo8q8ECXEeeKEZi9P2TNWQ" name="timing" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
        <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_gRZO0EGIEeej7Pd2CJeVfw" name="delay" visibility="private">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_skR8wEGIEeej7Pd2CJeVfw" value="1"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_UKabEGXIEeeOL4Q9GCeqlQ" name="flag">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Boolean"/>
        <defaultValue xmi:type="uml:LiteralBoolean" xmi:id="_X8flkGXIEeeOL4Q9GCeqlQ" value="true"/>
      </ownedAttribute>
      <ownedBehavior xmi:type="uml:StateMachine" xmi:id="_Q9xfYDvYEeeVBItGYDMaLQ" name="DetectionStateMachine" isReentrant="false">
        <region xmi:type="uml:Region" xmi:id="_Q96pUDvYEeeVBItGYDMaLQ" name="Region">
          <transition xmi:type="uml:Transition" xmi:id="_Q-G2kDvYEeeVBItGYDMaLQ" name="Initial" source="_Q9-TsDvYEeeVBItGYDMaLQ" target="_sSwBYECXEeeKEZi9P2TNWQ">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_2NdMkEF_Eeej7Pd2CJeVfw" name="Effect" isReentrant="false">
              <language>C++</language>
              <body></body>
            </effect>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_PFwLcECGEeeKEZi9P2TNWQ" name="" guard="_bMUXkGXIEeeOL4Q9GCeqlQ" source="_Q-DzQDvYEeeVBItGYDMaLQ" target="_Q-DzQDvYEeeVBItGYDMaLQ">
            <ownedRule xmi:type="uml:Constraint" xmi:id="_bMUXkGXIEeeOL4Q9GCeqlQ">
              <specification xmi:type="uml:OpaqueExpression" xmi:id="_bMU-oGXIEeeOL4Q9GCeqlQ">
                <language>C++</language>
                <body>return flag;</body>
              </specification>
            </ownedRule>
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_dv4kkEn9EeedZqJ4_o8GcQ" name="Effect" isReentrant="false">
              <language>C++</language>
              <body></body>
            </effect>
            <trigger xmi:type="uml:Trigger" xmi:id="_P7OLIECXEeeKEZi9P2TNWQ" port="_Oo8q8ECXEeeKEZi9P2TNWQ">
              <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
            </trigger>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_9Q7ZwECXEeeKEZi9P2TNWQ" name="" source="_sSwBYECXEeeKEZi9P2TNWQ" target="_Q-DzQDvYEeeVBItGYDMaLQ">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_UptqQEn9EeedZqJ4_o8GcQ" name="Effect" isReentrant="false">
              <language>C++</language>
              <body></body>
            </effect>
            <trigger xmi:type="uml:Trigger" xmi:id="_bmj7cECYEeeKEZi9P2TNWQ" event="_QT6zoDvkEeePyrL5fVHxNw" port="_raos0DvlEeePyrL5fVHxNw"/>
          </transition>
          <subvertex xmi:type="uml:Pseudostate" xmi:id="_Q9-TsDvYEeeVBItGYDMaLQ" name=""/>
          <subvertex xmi:type="uml:State" xmi:id="_Q-DzQDvYEeeVBItGYDMaLQ" name="Playing">
            <entry xmi:type="uml:OpaqueBehavior" xmi:id="_IsG1EDvhEeePyrL5fVHxNw" name="Entry" isReentrant="false">
              <language>C++</language>
              <body>//0 = up&#xD;
//1 = down&#xD;
//2 = left&#xD;
//3 = right&#xD;&#xD;
int c = 0; &#xD;&#xD;
switch((c=fgetc(stdin))){&#xD;&#xD;
case 119:&#xD;
directions.directions(0).send();&#xD;
break;&#xD;
case 115:&#xD;
directions.directions(1).send();&#xD;
break;&#xD;
case 97:&#xD;
directions.directions(2).send();&#xD;
break;&#xD;
case 100:&#xD;
directions.directions(3).send();&#xD;
break;&#xD;
case 27:&#xD;
directions.exits().send();&#xD;
log.log(&quot;Exiting&quot;);&#xD;
flag = false;
break;
}&#xD;
timing.informIn(UMLRTTimespec(this->delay,0));</body>
            </entry>
          </subvertex>
          <subvertex xmi:type="uml:State" xmi:id="_sSwBYECXEeeKEZi9P2TNWQ" name="Waiting">
            <entry xmi:type="uml:OpaqueBehavior" xmi:id="_HOnzMETQEeem9u7KRr3TyA" name="Entry" isReentrant="false">
              <language>C++</language>
              <body></body>
            </entry>
          </subvertex>
        </region>
      </ownedBehavior>
    </packagedElement>
    <packagedElement xmi:type="uml:Class" xmi:id="_LFgVYDvhEeePyrL5fVHxNw" name="Calculation" classifierBehavior="_Iz1_UDviEeePyrL5fVHxNw" isActive="true">
      <ownedAttribute xmi:type="uml:Port" xmi:id="_s71WoDvhEeePyrL5fVHxNw" name="directions" visibility="public" type="_EpeekDmbEeetSfDhTP5ZLQ" isOrdered="true" aggregation="composite" isBehavior="true"/>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_s58_8DvkEeePyrL5fVHxNw" name="test" visibility="public" type="_NBM7IDvjEeePyrL5fVHxNw" isOrdered="true" aggregation="composite" isBehavior="true"/>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_lz21EDvmEeePyrL5fVHxNw" name="startR" visibility="private">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_lz21ETvmEeePyrL5fVHxNw" value="85"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_ms43cEAbEeecSdgC5rjddw" name="directions3" visibility="protected" type="_EpeekDmbEeetSfDhTP5ZLQ" isOrdered="true" aggregation="composite" isBehavior="true" isService="false"/>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_-4kuQETPEeem9u7KRr3TyA" name="log" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
        <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6kIb0IeXEeSVyrlWP4nYew"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_lDpBoGfvEee-Kre0NmQF5w" name="emptyR" visibility="private">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_lDpBoWfvEee-Kre0NmQF5w" value="255"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_8uKyUHFoEeepH5jGTij4Cg" name="zombieR" visibility="private">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_8uKyUXFoEeepH5jGTij4Cg" value="170"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_XzqHYGfxEee-Kre0NmQF5w" name="map" visibility="private">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_FrqjEGf4Eee-Kre0NmQF5w" name="x" visibility="private">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_H2xecHFpEeepH5jGTij4Cg" value="0"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_JskMsGf4Eee-Kre0NmQF5w" name="y" visibility="private">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_I3bDIHFpEeepH5jGTij4Cg" value="0"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_KUyqUGf4Eee-Kre0NmQF5w" name="height" visibility="private">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_K5pD0Gf4Eee-Kre0NmQF5w" name="width" visibility="private">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_X-Zz4HFqEeepH5jGTij4Cg" name="zombieVector" visibility="private" type="_hizCkHIrEeeJYpdF89kMeA"/>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_iglUkHbNEeeXs9sY7gI7cA" name="zombies" visibility="private">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_HDU4wHbOEeeXs9sY7gI7cA" value="-1"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_57VOUHb6EeeKIIc_475P2A" name="test2" visibility="public" type="_NBM7IDvjEeePyrL5fVHxNw" isOrdered="true" aggregation="composite" isBehavior="true"/>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_7pOTgHb6EeeKIIc_475P2A" name="directions2" visibility="public" type="_EpeekDmbEeetSfDhTP5ZLQ" isOrdered="true" aggregation="composite" isBehavior="true"/>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_hqCNkHovEeesmeF6iS6c6Q" name="observation" visibility="protected" type="_fE_d9HovEeesmeF6iS6c6Q" isOrdered="true" aggregation="composite" isBehavior="true" isService="false"/>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_MqrREHvXEee7RKzKc_Azzg" name="startDirection">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_P57bUHvXEee7RKzKc_Azzg" value="0"/>
      </ownedAttribute>
      <ownedBehavior xmi:type="uml:StateMachine" xmi:id="_Iz1_UDviEeePyrL5fVHxNw" name="CalculationStateMachine" isReentrant="false">
        <region xmi:type="uml:Region" xmi:id="_Iz97IDviEeePyrL5fVHxNw" name="Region">
          <transition xmi:type="uml:Transition" xmi:id="_I0LWgDviEeePyrL5fVHxNw" name="Initial" source="_I0CMkDviEeePyrL5fVHxNw" target="_I0I6QDviEeePyrL5fVHxNw">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_ou1lcEn9EeedZqJ4_o8GcQ" name="Effect" isReentrant="false">
              <language>C++</language>
              <body>map = imread(&quot;external_resources/map.png&quot;);&#xD;
width = map.size().width;&#xD;
height = map.size().height;&#xD;
&#xD;
</body>
            </effect>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_3rHdsEAcEeecSdgC5rjddw" name="" source="_I0I6QDviEeePyrL5fVHxNw" target="_smFqAEAcEeecSdgC5rjddw">
            <trigger xmi:type="uml:Trigger" xmi:id="_amvTEEAdEeecSdgC5rjddw" event="_XB7xgDvpEeePyrL5fVHxNw" port="_ms43cEAbEeecSdgC5rjddw"/>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_Nni1gGftEee-Kre0NmQF5w" name="" source="_5hGJ0DvoEeePyrL5fVHxNw" target="_5hGJ0DvoEeePyrL5fVHxNw">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_O1jgwGftEee-Kre0NmQF5w" name="Effect" isReentrant="false">
              <language>C++</language>
              <body>    //0 = up
    //1 = down
    //2 = left
    //3 = right
    if (Direction==0){
    x = X;
    y = Y-1;
    } else if (Direction==1){
    x = X;
    y = Y+1;
    } else if (Direction==2){
    x = X-1;
    y = Y;
    } else if (Direction==3){
    x = X+1;
    y = Y;
    }
    Vec3b intensity = map.at&lt;Vec3b>(y, x);
    Vec3b pIntensity = map.at&lt;Vec3b>(Y,X);
    if (intensity.val[2] == emptyR){
    if (pIntensity.val[2] == startR){
    directions.directionCalc(x,y).send();
    intensity.val[2]=startR;
    } else if (pIntensity.val[2] == zombieR){
    directions2.directionCalc(x,y).send();
    intensity.val[2]=zombieR;
    }
    map.at&lt;Vec3b>(y,x) = intensity;
    pIntensity.val[2]=emptyR;
    map.at&lt;Vec3b>(Y,X) = pIntensity;
    std::vector&lt;int> compression_params;
    compression_params.push_back(CV_IMWRITE_PNG_COMPRESSION);
    compression_params.push_back(9);
    imwrite(&quot;external_resources/map.png&quot;, map, compression_params);
    } else if (intensity.val[2]== zombieR){
    directions2.exit().send();
}else {
     if (pIntensity.val[2] == startR){
    directions.directionCalc(X,Y).send();
    intensity.val[2]=startR;
    } else if (pIntensity.val[2] == zombieR){
    directions2.directionCalc(X,Y).send();
    intensity.val[2]=zombieR;
    }
    }
</body>
            </effect>
            <trigger xmi:type="uml:Trigger" xmi:id="_QSbHYGftEee-Kre0NmQF5w" event="_c26S8DmbEeetSfDhTP5ZLQ" port="_s71WoDvhEeePyrL5fVHxNw"/>
            <trigger xmi:type="uml:Trigger" xmi:id="_ru8oEHovEeesmeF6iS6c6Q" event="_c26S8DmbEeetSfDhTP5ZLQ" port="_7pOTgHb6EeeKIIc_475P2A"/>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_cv8lwGfyEee-Kre0NmQF5w" name="" source="_I0I6QDviEeePyrL5fVHxNw" target="_XrsowGfyEee-Kre0NmQF5w">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_h2g28GfyEee-Kre0NmQF5w" name="Effect" isReentrant="false">
              <language>C++</language>
              <body>    Vec3b intensity = map.at&lt;Vec3b>(y, x);
if  (intensity.val[2] == startR){
	test.isStartOut(x,y).send();
} else if (intensity.val[2]==zombieR){
Zombie tempZombie;
tempZombie.move(x,y);
tempZombie.changeDirection(startDirection);
zombieVector.addZVector(tempZombie);
}
width = map.size().width;
height = map.size().height;
</body>
            </effect>
            <trigger xmi:type="uml:Trigger" xmi:id="_d2IxwGfyEee-Kre0NmQF5w" event="_Wp6h0DvjEeePyrL5fVHxNw" port="_s58_8DvkEeePyrL5fVHxNw"/>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_2yuyMGfyEee-Kre0NmQF5w" name="found" guard="_7QNDEGfyEee-Kre0NmQF5w" source="_XrsowGfyEee-Kre0NmQF5w" target="_5hGJ0DvoEeePyrL5fVHxNw">
            <ownedRule xmi:type="uml:Constraint" xmi:id="_7QNDEGfyEee-Kre0NmQF5w">
              <specification xmi:type="uml:OpaqueExpression" xmi:id="_7QNqIGfyEee-Kre0NmQF5w">
                <language>C++</language>
                <body>    return y==height;
</body>
              </specification>
            </ownedRule>
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_WIAzAGfzEee-Kre0NmQF5w" name="Effect" isReentrant="false">
              <language>C++</language>
              <body>VectorWrapper wrapper;
wrapper.zombieVectorWrapper = zombieVector;
    
test2.zombieOut(wrapper, zombies).send();</body>
            </effect>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_9g89sGfyEee-Kre0NmQF5w" name="notFound" guard="_IUOTAGfzEee-Kre0NmQF5w" source="_XrsowGfyEee-Kre0NmQF5w" target="_XrsowGfyEee-Kre0NmQF5w">
            <ownedRule xmi:type="uml:Constraint" xmi:id="_IUOTAGfzEee-Kre0NmQF5w">
              <specification xmi:type="uml:OpaqueExpression" xmi:id="_IUOTAWfzEee-Kre0NmQF5w">
                <language>C++</language>
                <body>    return (y!=height);
</body>
              </specification>
            </ownedRule>
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_HXMDAGfzEee-Kre0NmQF5w" name="Effect" isReentrant="false">
              <language>C++</language>
              <body> if (x != width){
    x++;
    } else {
    if (y != height){
    y++;
    x = 0;
    }else{
    log.log(&quot;FAILURE&quot;);
    while(true){};
    }}
    Vec3b intensity = map.at&lt;Vec3b>(y, x);
    if  (intensity.val[2] == startR){
    test.isStartOut(x,y).send();
} else if (intensity.val[2]==zombieR){
Zombie tempZombie;
tempZombie.move(x,y);
tempZombie.changeDirection(startDirection);
zombieVector.addZVector(tempZombie);
zombies++;
}
</body>
            </effect>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_ETVbAGf0Eee-Kre0NmQF5w" name="" source="_5hGJ0DvoEeePyrL5fVHxNw" target="_smFqAEAcEeecSdgC5rjddw">
            <trigger xmi:type="uml:Trigger" xmi:id="_KbvjsGf0Eee-Kre0NmQF5w" event="_XB7xgDvpEeePyrL5fVHxNw" port="_ms43cEAbEeecSdgC5rjddw"/>
          </transition>
          <subvertex xmi:type="uml:Pseudostate" xmi:id="_I0CMkDviEeePyrL5fVHxNw" name=""/>
          <subvertex xmi:type="uml:State" xmi:id="_I0I6QDviEeePyrL5fVHxNw" name="Waiting">
            <entry xmi:type="uml:OpaqueBehavior" xmi:id="_8bExEETPEeem9u7KRr3TyA" name="Entry" isReentrant="false">
              <language>C++</language>
              <body></body>
            </entry>
          </subvertex>
          <subvertex xmi:type="uml:State" xmi:id="_5hGJ0DvoEeePyrL5fVHxNw" name="CoordinateCalculater">
            <entry xmi:type="uml:OpaqueBehavior" xmi:id="_xAEb0En9EeedZqJ4_o8GcQ" name="Entry" isReentrant="false">
              <language>C++</language>
              <body></body>
            </entry>
          </subvertex>
          <subvertex xmi:type="uml:State" xmi:id="_smFqAEAcEeecSdgC5rjddw" name="Exited">
            <entry xmi:type="uml:OpaqueBehavior" xmi:id="_BQ60IEn-EeedZqJ4_o8GcQ" name="Entry" isReentrant="false">
              <language>C++</language>
              <body>log.log(&quot;calculation exit&quot;);</body>
            </entry>
          </subvertex>
          <subvertex xmi:type="uml:Pseudostate" xmi:id="_XrsowGfyEee-Kre0NmQF5w" name="" kind="choice"/>
        </region>
      </ownedBehavior>
    </packagedElement>
    <packagedElement xmi:type="uml:Class" xmi:id="_FQa0MHL-EeeXs9sY7gI7cA" name="ZombieBehavior" classifierBehavior="_x3cf8HbEEeeXs9sY7gI7cA" isActive="true">
      <ownedAttribute xmi:type="uml:Port" xmi:id="_yYpdoHbGEeeXs9sY7gI7cA" name="test" visibility="public" type="_NBM7IDvjEeePyrL5fVHxNw" isOrdered="true" aggregation="composite" isBehavior="true" isConjugated="true" isService="true"/>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_hQSjoHbIEeeXs9sY7gI7cA" name="zombieVector" visibility="private" type="_hizCkHIrEeeJYpdF89kMeA"/>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_jEhPcHbKEeeXs9sY7gI7cA" name="timing" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
        <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_yU0JsHbKEeeXs9sY7gI7cA" name="delay" visibility="private">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_7HvX4HbKEeeXs9sY7gI7cA" value="1"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_9LZqAHbQEeeXs9sY7gI7cA" name="maxZombie" visibility="private" aggregation="none">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_V8nnQHbZEeeXs9sY7gI7cA" name="index" visibility="private">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_vEaVoHbaEeeXs9sY7gI7cA" name="directions" visibility="public" type="_EpeekDmbEeetSfDhTP5ZLQ" isOrdered="true" aggregation="composite" isBehavior="true" isConjugated="true" isService="true"/>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_S2NpcHb5EeeKIIc_475P2A" name="x" visibility="private">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_T44nYHb5EeeKIIc_475P2A" name="y" visibility="private">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_IZ8FkHb-EeeKIIc_475P2A" name="log" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
        <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6kIb0IeXEeSVyrlWP4nYew"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_k38wgHouEeesmeF6iS6c6Q" name="notFirstZombie" visibility="private">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Boolean"/>
        <defaultValue xmi:type="uml:LiteralBoolean" xmi:id="_pWD6kHouEeesmeF6iS6c6Q"/>
      </ownedAttribute>
      <ownedBehavior xmi:type="uml:StateMachine" xmi:id="_x3cf8HbEEeeXs9sY7gI7cA" name="StateMachine" isReentrant="false">
        <region xmi:type="uml:Region" xmi:id="_x3rJcHbEEeeXs9sY7gI7cA" name="Region">
          <transition xmi:type="uml:Transition" xmi:id="_x4Dj8HbEEeeXs9sY7gI7cA" name="Initial" source="_x3uMwHbEEeeXs9sY7gI7cA" target="_x4BHsHbEEeeXs9sY7gI7cA"/>
          <transition xmi:type="uml:Transition" xmi:id="_gHvSEHbGEeeXs9sY7gI7cA" name="" kind="external" source="_x4BHsHbEEeeXs9sY7gI7cA" target="_Xh0lIHbGEeeXs9sY7gI7cA">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_NKuuIHbJEeeXs9sY7gI7cA" name="Effect" isReentrant="false">
              <language>C++</language>
              <body>zombieVector = data.zombieVectorWrapper;
maxZombie = max;
index = max+1;</body>
            </effect>
            <trigger xmi:type="uml:Trigger" xmi:id="_8Dpt4HbHEeeXs9sY7gI7cA" event="_rjK0AHFqEeepH5jGTij4Cg" port="_yYpdoHbGEeeXs9sY7gI7cA"/>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_en3BcHbLEeeXs9sY7gI7cA" name="" kind="external" source="_Xh0lIHbGEeeXs9sY7gI7cA" target="_IVV5QHbZEeeXs9sY7gI7cA">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_1lPNMHouEeesmeF6iS6c6Q" name="Effect" isReentrant="false">
              <language>C++</language>
              <body>notFirstZombie = true;</body>
            </effect>
            <trigger xmi:type="uml:Trigger" xmi:id="_oyV4cHbLEeeXs9sY7gI7cA" port="_jEhPcHbKEeeXs9sY7gI7cA">
              <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
            </trigger>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_UfmiwHbxEeeKIIc_475P2A" name="" kind="external" source="_IVV5QHbZEeeXs9sY7gI7cA" target="_Xh0lIHbGEeeXs9sY7gI7cA">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_RWT1kHb8EeeKIIc_475P2A" name="Effect" isReentrant="false">
              <language>C++</language>
              <body>Zombie tempZombie = zombieVector.getZombie(index);
tempZombie.move(X,Y);
zombieVector.zVector.at(index) = tempZombie;</body>
            </effect>
            <trigger xmi:type="uml:Trigger" xmi:id="_KvI0oHb5EeeKIIc_475P2A" event="_Pyh2oDmbEeetSfDhTP5ZLQ" port="_vEaVoHbaEeeXs9sY7gI7cA"/>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_HKFkEHb6EeeKIIc_475P2A" name="" kind="external" source="_Xh0lIHbGEeeXs9sY7gI7cA" target="_Xh0lIHbGEeeXs9sY7gI7cA">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_Rw7VAHb8EeeKIIc_475P2A" name="Effect" isReentrant="false">
              <language>C++</language>
              <body>Zombie tempZombie = zombieVector.getZombie(index);
tempZombie.move(X,Y);
zombieVector.zVector.at(index) = tempZombie;</body>
            </effect>
            <trigger xmi:type="uml:Trigger" xmi:id="_INLYwHb6EeeKIIc_475P2A" event="_Pyh2oDmbEeetSfDhTP5ZLQ" port="_vEaVoHbaEeeXs9sY7gI7cA"/>
          </transition>
          <subvertex xmi:type="uml:Pseudostate" xmi:id="_x3uMwHbEEeeXs9sY7gI7cA" kind="initial">
            <name xsi:nil="true"/>
          </subvertex>
          <subvertex xmi:type="uml:State" xmi:id="_x4BHsHbEEeeXs9sY7gI7cA" name="Waiting"/>
          <subvertex xmi:type="uml:State" xmi:id="_Xh0lIHbGEeeXs9sY7gI7cA" name="Recieved">
            <entry xmi:type="uml:OpaqueBehavior" xmi:id="_ckZfcHbMEeeXs9sY7gI7cA" name="Entry" isReentrant="false">
              <language>C++</language>
              <body>if (notFirstZombie){
Zombie tempZombie = zombieVector.getZombie(index);
    if (x ==  tempZombie.getX() &amp;&amp; y == tempZombie.getY()){
    switch(tempZombie.currentDirection()){
    case 0: 
    tempZombie.changeDirection(1);
    break;
    case 1: 
    tempZombie.changeDirection(0);
    break;
    case 2: 
    tempZombie.changeDirection(3);
    break;
    case 3: 
    tempZombie.changeDirection(2);
    break;
    }
    zombieVector.zVector.at(index) = tempZombie;
    }
    index = index + 1;
    if (index &lt;= maxZombie){
    x = zombieVector.getZombie(index).getX();
    y = zombieVector.getZombie(index).getY();
    directions.directionsCalc(x, y, zombieVector.getZombie(index).currentDirection()).send();
    }
    }
    if (index > maxZombie){
    index = 0;
    notFirstZombie = false;
    timing.informIn(UMLRTTimespec(this->delay,0));
    }</body>
            </entry>
          </subvertex>
          <subvertex xmi:type="uml:State" xmi:id="_IVV5QHbZEeeXs9sY7gI7cA" name="Start">
            <entry xmi:type="uml:OpaqueBehavior" xmi:id="_jncAYHb4EeeKIIc_475P2A" name="Entry" isReentrant="false">
              <language>C++</language>
              <body>    x = zombieVector.getZombie(index).getX();
    y = zombieVector.getZombie(index).getY();
    directions.directionsCalc(x, y, zombieVector.getZombie(index).currentDirection()).send();
</body>
            </entry>
          </subvertex>
        </region>
      </ownedBehavior>
    </packagedElement>
    <packagedElement xmi:type="uml:Class" xmi:id="_VDAPMHFpEeepH5jGTij4Cg" name="Zombie" visibility="public">
      <ownedAttribute xmi:type="uml:Property" xmi:id="_ZhUNkHFpEeepH5jGTij4Cg" name="x" visibility="public">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_bcvYcHFpEeepH5jGTij4Cg" name="y" visibility="public">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_eTN2UHFpEeepH5jGTij4Cg" name="d" visibility="public">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
      </ownedAttribute>
      <ownedBehavior xmi:type="uml:OpaqueBehavior" xmi:id="_oftwYHI2EeeJYpdF89kMeA" name="moveImpl" specification="_8ypNMHFpEeepH5jGTij4Cg">
        <language>C++</language>
        <body>    this->x = newX;
    this->y = newY;
</body>
      </ownedBehavior>
      <ownedBehavior xmi:type="uml:OpaqueBehavior" xmi:id="_vOIwMHI2EeeJYpdF89kMeA" name="getXImpl" specification="_rl6sUHI2EeeJYpdF89kMeA">
        <language>C++</language>
        <body>    return x;
</body>
      </ownedBehavior>
      <ownedBehavior xmi:type="uml:OpaqueBehavior" xmi:id="_v9RuIHI2EeeJYpdF89kMeA" name="getYImpl" specification="_tOrZ4HI2EeeJYpdF89kMeA">
        <language>C++</language>
        <body>    return y;
</body>
      </ownedBehavior>
      <ownedBehavior xmi:type="uml:OpaqueBehavior" xmi:id="_110O0HI2EeeJYpdF89kMeA" name="changeDirectionImpl" specification="_JtUT4HFqEeepH5jGTij4Cg">
        <language>C++</language>
        <body>this->d = newD;
</body>
      </ownedBehavior>
      <ownedBehavior xmi:type="uml:OpaqueBehavior" xmi:id="_6vukEHI2EeeJYpdF89kMeA" name="currentDirectionImpl" specification="_NKMqcHFqEeepH5jGTij4Cg">
        <language>C++</language>
        <body>
return (d);
</body>
      </ownedBehavior>
      <ownedOperation xmi:type="uml:Operation" xmi:id="_8ypNMHFpEeepH5jGTij4Cg" name="move" method="_oftwYHI2EeeJYpdF89kMeA">
        <ownedParameter xmi:type="uml:Parameter" xmi:id="_8ypNMXFpEeepH5jGTij4Cg" name="newX">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedParameter>
        <ownedParameter xmi:type="uml:Parameter" xmi:id="_8ypNMnFpEeepH5jGTij4Cg" name="newY">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedParameter>
      </ownedOperation>
      <ownedOperation xmi:type="uml:Operation" xmi:id="_JtUT4HFqEeepH5jGTij4Cg" name="changeDirection" method="_110O0HI2EeeJYpdF89kMeA">
        <ownedParameter xmi:type="uml:Parameter" xmi:id="_JtUT4XFqEeepH5jGTij4Cg" name="newD" effect="create">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedParameter>
      </ownedOperation>
      <ownedOperation xmi:type="uml:Operation" xmi:id="_NKMqcHFqEeepH5jGTij4Cg" name="currentDirection" method="_6vukEHI2EeeJYpdF89kMeA">
        <ownedParameter xmi:type="uml:Parameter" xmi:id="_SHn4gHLwEeeMk9-J2CGulw" direction="return">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedParameter>
      </ownedOperation>
      <ownedOperation xmi:type="uml:Operation" xmi:id="_rl6sUHI2EeeJYpdF89kMeA" name="getX" method="_vOIwMHI2EeeJYpdF89kMeA">
        <ownedParameter xmi:type="uml:Parameter" xmi:id="_VQ5WkHLwEeeMk9-J2CGulw" direction="return">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedParameter>
      </ownedOperation>
      <ownedOperation xmi:type="uml:Operation" xmi:id="_tOrZ4HI2EeeJYpdF89kMeA" name="getY" method="_v9RuIHI2EeeJYpdF89kMeA">
        <ownedParameter xmi:type="uml:Parameter" xmi:id="_XwwEMHLwEeeMk9-J2CGulw" direction="return">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedParameter>
      </ownedOperation>
    </packagedElement>
    <packagedElement xmi:type="uml:Class" xmi:id="_hizCkHIrEeeJYpdF89kMeA" name="Vector">
      <ownedAttribute xmi:type="uml:Property" xmi:id="_sgoCEHIrEeeJYpdF89kMeA" name="zVector" visibility="public">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
      </ownedAttribute>
      <ownedBehavior xmi:type="uml:OpaqueBehavior" xmi:id="_kclAMHI4EeeJYpdF89kMeA" specification="_cr1AsHI4EeeJYpdF89kMeA">
        <language>C++</language>
        <body>    zVector.push_back(newV);
</body>
      </ownedBehavior>
      <ownedBehavior xmi:type="uml:OpaqueBehavior" xmi:id="_SmVgwHcBEeezX_4gmeWOEg" specification="_PoDKsHcBEeezX_4gmeWOEg">
        <language>C++</language>
        <body>    return zVector[index];
</body>
      </ownedBehavior>
      <ownedOperation xmi:type="uml:Operation" xmi:id="_cr1AsHI4EeeJYpdF89kMeA" name="addZVector" method="_kclAMHI4EeeJYpdF89kMeA">
        <ownedParameter xmi:type="uml:Parameter" xmi:id="_cr1AsXI4EeeJYpdF89kMeA" name="newV" type="_VDAPMHFpEeepH5jGTij4Cg"/>
      </ownedOperation>
      <ownedOperation xmi:type="uml:Operation" xmi:id="_PoDKsHcBEeezX_4gmeWOEg" name="getZombie" method="_SmVgwHcBEeezX_4gmeWOEg">
        <ownedParameter xmi:type="uml:Parameter" xmi:id="_PoDKsXcBEeezX_4gmeWOEg" name="index">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedParameter>
        <ownedParameter xmi:type="uml:Parameter" xmi:id="_PoDKsncBEeezX_4gmeWOEg" type="_VDAPMHFpEeepH5jGTij4Cg" direction="return"/>
      </ownedOperation>
    </packagedElement>
    <packagedElement xmi:type="uml:Class" xmi:id="_ONiHkHuuEee7RKzKc_Azzg" name="VectorWrapper">
      <ownedAttribute xmi:type="uml:Property" xmi:id="_aDrPIHuuEee7RKzKc_Azzg" name="zombieVectorWrapper" visibility="public" type="_hizCkHIrEeeJYpdF89kMeA"/>
    </packagedElement>
    <packagedElement xmi:type="uml:Package" xmi:id="_fE_d8HovEeesmeF6iS6c6Q" name="Observation">
      <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_fE_d8XovEeesmeF6iS6c6Q" source="http://www.eclipse.org/papyrus-rt/language/1.0.0">
        <details xmi:type="ecore:EStringToStringMapEntry" xmi:id="_fE_d8novEeesmeF6iS6c6Q" key="language" value="umlrt-cpp"/>
      </eAnnotations>
      <packagedElement xmi:type="uml:Package" xmi:id="_fE_d83ovEeesmeF6iS6c6Q" name="Observation">
        <packagedElement xmi:type="uml:Collaboration" xmi:id="_fE_d9HovEeesmeF6iS6c6Q" name="Observation">
          <interfaceRealization xmi:type="uml:InterfaceRealization" xmi:id="_fE_d9XovEeesmeF6iS6c6Q" client="_fE_d9HovEeesmeF6iS6c6Q" supplier="_fE_d93ovEeesmeF6iS6c6Q" contract="_fE_d93ovEeesmeF6iS6c6Q"/>
          <interfaceRealization xmi:type="uml:InterfaceRealization" xmi:id="_fE_d9novEeesmeF6iS6c6Q" client="_fE_d9HovEeesmeF6iS6c6Q" supplier="_fE_d_XovEeesmeF6iS6c6Q" contract="_fE_d_XovEeesmeF6iS6c6Q"/>
        </packagedElement>
        <packagedElement xmi:type="uml:Interface" xmi:id="_fE_d93ovEeesmeF6iS6c6Q" name="Observation"/>
        <packagedElement xmi:type="uml:Interface" xmi:id="_fE_d-HovEeesmeF6iS6c6Q" name="Observation~">
          <ownedOperation xmi:type="uml:Operation" xmi:id="_fE_d-XovEeesmeF6iS6c6Q" name="event">
            <ownedParameter xmi:type="uml:Parameter" xmi:id="_fE_d-novEeesmeF6iS6c6Q" name="data" type="_fE_eHXovEeesmeF6iS6c6Q"/>
          </ownedOperation>
        </packagedElement>
        <packagedElement xmi:type="uml:Usage" xmi:id="_fE_d-3ovEeesmeF6iS6c6Q" client="_fE_d9HovEeesmeF6iS6c6Q" supplier="_fE_d-HovEeesmeF6iS6c6Q"/>
        <packagedElement xmi:type="uml:AnyReceiveEvent" xmi:id="_fE_d_HovEeesmeF6iS6c6Q" name="*"/>
        <packagedElement xmi:type="uml:Interface" xmi:id="_fE_d_XovEeesmeF6iS6c6Q" name="ObservationIO"/>
        <packagedElement xmi:type="uml:Usage" xmi:id="_fE_d_novEeesmeF6iS6c6Q" client="_fE_d9HovEeesmeF6iS6c6Q" supplier="_fE_d_XovEeesmeF6iS6c6Q"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_fE_d_3ovEeesmeF6iS6c6Q" operation="_fE_d-XovEeesmeF6iS6c6Q"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="_fE_eAHovEeesmeF6iS6c6Q" name="Observer" classifierBehavior="_fE_eBnovEeesmeF6iS6c6Q" isActive="true">
        <ownedAttribute xmi:type="uml:Port" xmi:id="_fE_eAXovEeesmeF6iS6c6Q" name="observation" visibility="public" type="_fE_d9HovEeesmeF6iS6c6Q" isOrdered="true" aggregation="composite" isBehavior="true" isConjugated="true">
          <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_fE_eAnovEeesmeF6iS6c6Q" value="20"/>
          <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_fE_eA3ovEeesmeF6iS6c6Q" value="20"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_fE_eBHovEeesmeF6iS6c6Q" name="log" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6kIb0IeXEeSVyrlWP4nYew"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_fE_eBXovEeesmeF6iS6c6Q" name="timer" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedBehavior xmi:type="uml:StateMachine" xmi:id="_fE_eBnovEeesmeF6iS6c6Q" name="ObserverStateMachine" isReentrant="false">
          <region xmi:type="uml:Region" xmi:id="_fE_eB3ovEeesmeF6iS6c6Q" name="Region">
            <transition xmi:type="uml:Transition" xmi:id="_fE_eCHovEeesmeF6iS6c6Q" name="configure" source="_fE_eE3ovEeesmeF6iS6c6Q" target="_fE_eFHovEeesmeF6iS6c6Q">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_fE_eCXovEeesmeF6iS6c6Q">
                <language>C++</language>
                <body>int n = config.load();
log.show(&quot;Number of entries: %d\n&quot;, n);

// Socket
this->method = new Socket();
this->method->configure(config.getConfigList());
this->method->connect();

// Text 
this->serializer = new Text();
this->serializer->configure(config.getConfigList());

// Instantiating the timer
timer.informEvery(UMLRTTimespec(0,500000000));</body>
              </effect>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_fE_eCnovEeesmeF6iS6c6Q" name="event received" source="_fE_eFHovEeesmeF6iS6c6Q" target="_fE_eFHovEeesmeF6iS6c6Q">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_fE_eC3ovEeesmeF6iS6c6Q">
                <language>C++</language>
                <body>std::string str = this->serializer->serialize(data.event) + &quot;\n&quot;;
this->method->sendData(str);</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_fE_eDHovEeesmeF6iS6c6Q" event="_fE_d_3ovEeesmeF6iS6c6Q" port="_fE_eAXovEeesmeF6iS6c6Q"/>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_fE_eDXovEeesmeF6iS6c6Q" name="command received" source="_fE_eFHovEeesmeF6iS6c6Q" target="_fE_eFHovEeesmeF6iS6c6Q">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_fE_eDnovEeesmeF6iS6c6Q">
                <language>C++</language>
                <body>std::string data = this->method->read();
    std::stringstream ss;
    if (data != &quot;&quot;) {

        std::istringstream iss(data);
        std::vector&lt;std::string> cmd;
        while (iss) {
            std::string subs;
            iss >> subs; 
            if (iss != &quot;&quot;) {
                cmd.push_back(subs);
            }
        }

        if (cmd.size() == 0)
            return;

        if (cmd.size() > 1 &amp;&amp; cmd[0] == &quot;list&quot; &amp;&amp; cmd[1] == &quot;capsules&quot;) {
            ss  &lt;&lt; &quot;List of capsules:\n&quot;;
            std::map&lt;std::string, size_t>::iterator iter;
            for(iter=capsules.begin(); iter!=capsules.end(); ++iter) {
                ss &lt;&lt; &quot; - &quot; &lt;&lt; iter->first &lt;&lt; &quot; [&quot;&lt;&lt; capsuleTypes[iter->first]&lt;&lt; &quot;]\n&quot;;
            }
            this->method->sendData(ss.str());
        }
        else if (cmd.size() > 2 &amp;&amp; cmd[0] == &quot;show&quot; &amp;&amp; cmd[1] == &quot;capsule&quot;) {

            printf(&quot;capsule:%s|type:%s\n&quot;, cmd[1].c_str(), capsuleTypes[cmd[2]].c_str());
            if (capsuleTypes[cmd[2]] == &quot;&quot;) {
                printf(&quot;error: %s\n&quot;, capsuleTypes[cmd[2]].c_str());
                return;
            }
            std::string capsuleType = capsuleTypes[cmd[2]];
            ss  &lt;&lt; &quot;Capsule: &quot; &lt;&lt; cmd[2];
            ss  &lt;&lt; &quot; type: &quot; &lt;&lt; capsuleTypes[cmd[2]] &lt;&lt; &quot;\n&quot;;
            ss  &lt;&lt; &quot;List of triggers:\n&quot;;
            if (capsuleType == &quot;Gen&quot;) {
                ss &lt;&lt; &quot; - &quot; &lt;&lt; &quot;generate()\n&quot;;
                this->method->sendData(ss.str());
            }
        }

    }</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_fE_eD3ovEeesmeF6iS6c6Q" port="_fE_eBXovEeesmeF6iS6c6Q">
                <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
              </trigger>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_fE_eEHovEeesmeF6iS6c6Q" name="register capsules" source="_fE_eFHovEeesmeF6iS6c6Q" target="_fE_eFHovEeesmeF6iS6c6Q">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_fE_eEXovEeesmeF6iS6c6Q">
                <language>C++</language>
                <body>std::stringstream ss;
    ss &lt;&lt; msg->signal.getSrcPort()->slot->name &lt;&lt; &quot;:&quot; &lt;&lt; msg->signal.getSrcPort()->slot->capsuleIndex;
    printf(&quot;capsule name: %s\n&quot;, ss.str().c_str());
    capsules[ss.str()] = msg->srcPortIndex;
    capsuleTypes[ss.str()] = msg->signal.getSrcPort()->slot->capsuleClass->name;</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_fE_eEnovEeesmeF6iS6c6Q" port="_fE_eAXovEeesmeF6iS6c6Q">
                <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_PQtAwOzeEeSRtqCWFwOf8g"/>
              </trigger>
            </transition>
            <subvertex xmi:type="uml:Pseudostate" xmi:id="_fE_eE3ovEeesmeF6iS6c6Q">
              <name xsi:nil="true"/>
            </subvertex>
            <subvertex xmi:type="uml:State" xmi:id="_fE_eFHovEeesmeF6iS6c6Q" name="OBSERVING"/>
          </region>
        </ownedBehavior>
      </packagedElement>
      <packagedElement xmi:type="uml:Package" xmi:id="_fE_eFXovEeesmeF6iS6c6Q" name="internal">
        <packagedElement xmi:type="uml:Artifact" xmi:id="_fE_eFnovEeesmeF6iS6c6Q" name="Event"/>
        <packagedElement xmi:type="uml:Artifact" xmi:id="_fE_eF3ovEeesmeF6iS6c6Q" name="CLIUtils"/>
        <packagedElement xmi:type="uml:Artifact" xmi:id="_fE_eGHovEeesmeF6iS6c6Q" name="Serializer"/>
        <packagedElement xmi:type="uml:Artifact" xmi:id="_fE_eGXovEeesmeF6iS6c6Q" name="Method"/>
        <packagedElement xmi:type="uml:Artifact" xmi:id="_fE_eGnovEeesmeF6iS6c6Q" name="Text"/>
        <packagedElement xmi:type="uml:Artifact" xmi:id="_fE_eG3ovEeesmeF6iS6c6Q" name="Socket"/>
        <packagedElement xmi:type="uml:Artifact" xmi:id="_fE_eHHovEeesmeF6iS6c6Q" name="Config"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="_fE_eHXovEeesmeF6iS6c6Q" name="EventObj"/>
      <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_fE_eHnovEeesmeF6iS6c6Q">
        <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_fE_eH3ovEeesmeF6iS6c6Q" source="http://www.eclipse.org/uml2/2.0.0/UML">
          <references xmi:type="ecore:EPackage" href="http://www.eclipse.org/papyrus/umlrt#/"/>
        </eAnnotations>
        <appliedProfile xmi:type="uml:Profile" href="pathmap://UML_RT_PROFILE/uml-rt.profile.uml#_1h74oEeVEeO0lv5O1DTHOQ"/>
      </profileApplication>
      <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_fE_eIHovEeesmeF6iS6c6Q">
        <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_fE_eIXovEeesmeF6iS6c6Q" source="http://www.eclipse.org/uml2/2.0.0/UML">
          <references xmi:type="ecore:EPackage" href="http://www.eclipse.org/papyrus/umlrt/cppproperties#/"/>
        </eAnnotations>
        <appliedProfile xmi:type="uml:Profile" href="pathmap://UMLRT_CPP/RTCppProperties.profile.uml#_vl5LALs8EeSTjNEQkASznQ"/>
      </profileApplication>
      <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_fE_eInovEeesmeF6iS6c6Q">
        <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_fE_eI3ovEeesmeF6iS6c6Q" source="http://www.eclipse.org/uml2/2.0.0/UML">
          <references xmi:type="ecore:EPackage" href="http://www.eclipse.org/papyrus/umlrt/statemachine#/"/>
        </eAnnotations>
        <appliedProfile xmi:type="uml:Profile" href="pathmap://UML_RT_PROFILE/UMLRealTimeSM-addendum.profile.uml#_KLcn0FDtEeOA4ecmvfqvaw"/>
      </profileApplication>
    </packagedElement>
    <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_g0QeczbLEeeS0ZUearuafA">
      <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_g0QedDbLEeeS0ZUearuafA" source="http://www.eclipse.org/uml2/2.0.0/UML">
        <references xmi:type="ecore:EPackage" href="http://www.eclipse.org/papyrus/umlrt#/"/>
      </eAnnotations>
      <appliedProfile xmi:type="uml:Profile" href="pathmap://UML_RT_PROFILE/uml-rt.profile.uml#_1h74oEeVEeO0lv5O1DTHOQ"/>
    </profileApplication>
    <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_g0QedTbLEeeS0ZUearuafA">
      <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_g0QedjbLEeeS0ZUearuafA" source="http://www.eclipse.org/uml2/2.0.0/UML">
        <references xmi:type="ecore:EPackage" href="http://www.eclipse.org/papyrus/umlrt/statemachine#/"/>
      </eAnnotations>
      <appliedProfile xmi:type="uml:Profile" href="pathmap://UML_RT_PROFILE/UMLRealTimeSM-addendum.profile.uml#_KLcn0FDtEeOA4ecmvfqvaw"/>
    </profileApplication>
    <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_jIwgADtSEeejkKe0yPo-pQ">
      <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_jI5C4DtSEeejkKe0yPo-pQ" source="http://www.eclipse.org/uml2/2.0.0/UML">
        <references xmi:type="ecore:EPackage" href="pathmap://UML_PROFILES/Ecore.profile.uml#_z1OFcHjqEdy8S4Cr8Rc_NA"/>
      </eAnnotations>
      <appliedProfile xmi:type="uml:Profile" href="pathmap://UML_PROFILES/Ecore.profile.uml#_0"/>
    </profileApplication>
    <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_x37eMDvWEeeVBItGYDMaLQ">
      <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_x4AWsDvWEeeVBItGYDMaLQ" source="http://www.eclipse.org/uml2/2.0.0/UML">
        <references xmi:type="ecore:EPackage" href="http://www.eclipse.org/papyrus/umlrt/cppproperties#/"/>
      </eAnnotations>
      <appliedProfile xmi:type="uml:Profile" href="pathmap://UMLRT_CPP/RTCppProperties.profile.uml#_vl5LALs8EeSTjNEQkASznQ"/>
    </profileApplication>
    <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_zKMYoEt_EeeD4eyKVO2S_Q">
      <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_zLdj8Et_EeeD4eyKVO2S_Q" source="http://www.eclipse.org/uml2/2.0.0/UML">
        <references xmi:type="ecore:EPackage" href="pathmap://PAPYRUS_ACTIONLANGUAGE_PROFILE/ActionLanguage-Profile.profile.uml#_Kv8EIKFXEeS_KNX0nfvIVQ"/>
      </eAnnotations>
      <appliedProfile xmi:type="uml:Profile" href="pathmap://PAPYRUS_ACTIONLANGUAGE_PROFILE/ActionLanguage-Profile.profile.uml#ActionLanguage"/>
    </profileApplication>
    <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_fFB6N3ovEeesmeF6iS6c6Q">
      <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_fFChQHovEeesmeF6iS6c6Q" source="http://www.eclipse.org/uml2/2.0.0/UML">
        <references xmi:type="ecore:EPackage" href="platform:/plugin/ca.queensu.cs.observer.profile/model/observation.profile.uml#_JM7lAAsfEeeNyaUjNhkxlQ"/>
      </eAnnotations>
      <appliedProfile xmi:type="uml:Profile" href="platform:/plugin/ca.queensu.cs.observer.profile/model/observation.profile.uml#_r-waoAseEeeNyaUjNhkxlQ"/>
    </profileApplication>
  </uml:Model>
  <UMLRealTime:Capsule xmi:id="_CFgKwDbOEeeS0ZUearuafA" base_Class="_B6RyMDbOEeeS0ZUearuafA"/>
  <UMLRealTime:Capsule xmi:id="_9zOAwDbOEeeS0ZUearuafA" base_Class="_9yzxEDbOEeeS0ZUearuafA"/>
  <UMLRealTime:RTPort xmi:id="_XuhsMDbPEeeS0ZUearuafA" isWired="false" base_Port="_XtyFUDbPEeeS0ZUearuafA"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_cPG7cDbPEeeS0ZUearuafA" base_Pseudostate="_cPCC8DbPEeeS0ZUearuafA"/>
  <UMLRTStateMachines:RTState xmi:id="_cPYBMDbPEeeS0ZUearuafA" base_State="_cPUW0DbPEeeS0ZUearuafA"/>
  <UMLRTStateMachines:RTRegion xmi:id="_cPnRwDbPEeeS0ZUearuafA" base_Region="_cO45ADbPEeeS0ZUearuafA"/>
  <UMLRTStateMachines:RTStateMachine xmi:id="_cQv6MDbPEeeS0ZUearuafA" base_StateMachine="_cOGO0DbPEeeS0ZUearuafA"/>
  <UMLRealTime:RTPort xmi:id="_lIjewDeHEee0Cb7xo9L6qw" isPublish="true" isWired="false" base_Port="_lIhCgDeHEee0Cb7xo9L6qw"/>
  <UMLRealTime:CapsulePart xmi:id="_SQKGkDliEeeHA4oSpVV8Ow" base_Property="_SQAVkDliEeeHA4oSpVV8Ow"/>
  <UMLRTStateMachines:RTState xmi:id="_KertgDmSEeetSfDhTP5ZLQ" base_State="_Kep4UDmSEeetSfDhTP5ZLQ"/>
  <UMLRealTime:ProtocolContainer xmi:id="_Epg60DmbEeetSfDhTP5ZLQ" base_Package="_EpgTwDmbEeetSfDhTP5ZLQ"/>
  <UMLRealTime:RTMessageSet xmi:id="_EpiwADmbEeetSfDhTP5ZLQ" base_Interface="_Ephh4DmbEeetSfDhTP5ZLQ"/>
  <UMLRealTime:RTMessageSet xmi:id="_Epj-IDmbEeetSfDhTP5ZLQ" base_Interface="_EpjXEDmbEeetSfDhTP5ZLQ" rtMsgKind="out"/>
  <UMLRealTime:RTMessageSet xmi:id="_EplzUDmbEeetSfDhTP5ZLQ" base_Interface="_EplMQDmbEeetSfDhTP5ZLQ" rtMsgKind="inOut"/>
  <UMLRealTime:Protocol xmi:id="_EpnBcDmbEeetSfDhTP5ZLQ" base_Collaboration="_EpeekDmbEeetSfDhTP5ZLQ"/>
  <UMLRealTime:Capsule xmi:id="__8C0ODmcEeetSfDhTP5ZLQ" base_Class="__7sO4DmcEeetSfDhTP5ZLQ"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_HTaJoDppEeehJIRyir005Q" base_Pseudostate="_HTXtYDppEeehJIRyir005Q"/>
  <UMLRTStateMachines:RTState xmi:id="_HTdM8DppEeehJIRyir005Q" base_State="_HTb-0DppEeehJIRyir005Q"/>
  <UMLRTStateMachines:RTRegion xmi:id="_HTebEDppEeehJIRyir005Q" base_Region="_HTUDADppEeehJIRyir005Q"/>
  <UMLRTStateMachines:RTStateMachine xmi:id="_HUiLADppEeehJIRyir005Q" base_StateMachine="_HTMHMDppEeehJIRyir005Q"/>
  <UMLRealTime:Capsule xmi:id="_JMnCsDs0Eee4vrzjGIvOwQ" base_Class="_JK_5IDs0Eee4vrzjGIvOwQ"/>
  <UMLRealTime:CapsulePart xmi:id="___b2kDs1Eee4vrzjGIvOwQ" base_Property="___ZaUDs1Eee4vrzjGIvOwQ"/>
  <UMLRealTime:RTPort xmi:id="_HBPk0DvYEeeVBItGYDMaLQ" base_Port="_HBMhgDvYEeeVBItGYDMaLQ"/>
  <UMLRealTime:RTPort xmi:id="_JOxMUDvYEeeVBItGYDMaLQ" isWired="false" base_Port="_JOth8DvYEeeVBItGYDMaLQ"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_Q-BXADvYEeeVBItGYDMaLQ" base_Pseudostate="_Q9-TsDvYEeeVBItGYDMaLQ"/>
  <UMLRTStateMachines:RTState xmi:id="_Q-GPgDvYEeeVBItGYDMaLQ" base_State="_Q-DzQDvYEeeVBItGYDMaLQ"/>
  <UMLRTStateMachines:RTRegion xmi:id="_Q-IEsDvYEeeVBItGYDMaLQ" base_Region="_Q96pUDvYEeeVBItGYDMaLQ"/>
  <UMLRTStateMachines:RTStateMachine xmi:id="_Q_KmgDvYEeeVBItGYDMaLQ" base_StateMachine="_Q9xfYDvYEeeVBItGYDMaLQ"/>
  <UMLRealTime:Capsule xmi:id="_LG9t8DvhEeePyrL5fVHxNw" base_Class="_LFgVYDvhEeePyrL5fVHxNw"/>
  <UMLRealTime:RTPort xmi:id="_s795gDvhEeePyrL5fVHxNw" base_Port="_s71WoDvhEeePyrL5fVHxNw"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_I0HFEDviEeePyrL5fVHxNw" base_Pseudostate="_I0CMkDviEeePyrL5fVHxNw"/>
  <UMLRTStateMachines:RTState xmi:id="_I0KvcDviEeePyrL5fVHxNw" base_State="_I0I6QDviEeePyrL5fVHxNw"/>
  <UMLRTStateMachines:RTRegion xmi:id="_I0MkoDviEeePyrL5fVHxNw" base_Region="_Iz97IDviEeePyrL5fVHxNw"/>
  <UMLRTStateMachines:RTStateMachine xmi:id="_I0wlUDviEeePyrL5fVHxNw" base_StateMachine="_Iz1_UDviEeePyrL5fVHxNw"/>
  <UMLRealTime:ProtocolContainer xmi:id="_NBX6QDvjEeePyrL5fVHxNw" base_Package="_NBRMkDvjEeePyrL5fVHxNw"/>
  <UMLRealTime:RTMessageSet xmi:id="_NBdZ0DvjEeePyrL5fVHxNw" base_Interface="_NBZIYDvjEeePyrL5fVHxNw"/>
  <UMLRealTime:RTMessageSet xmi:id="_NBhEMDvjEeePyrL5fVHxNw" base_Interface="_NBf2EDvjEeePyrL5fVHxNw" rtMsgKind="out"/>
  <UMLRealTime:RTMessageSet xmi:id="_NBmjwDvjEeePyrL5fVHxNw" base_Interface="_NBkHgDvjEeePyrL5fVHxNw" rtMsgKind="inOut"/>
  <UMLRealTime:Protocol xmi:id="_NBpAADvjEeePyrL5fVHxNw" base_Collaboration="_NBM7IDvjEeePyrL5fVHxNw"/>
  <UMLRealTime:CapsulePart xmi:id="_hV3RsDvkEeePyrL5fVHxNw" base_Property="_hV01cDvkEeePyrL5fVHxNw"/>
  <UMLRealTime:RTPort xmi:id="_s5_cMDvkEeePyrL5fVHxNw" base_Port="_s58_8DvkEeePyrL5fVHxNw"/>
  <UMLRealTime:CapsulePart xmi:id="_0JbeYDvkEeePyrL5fVHxNw" base_Property="_0JZCIDvkEeePyrL5fVHxNw"/>
  <UMLRealTime:RTPort xmi:id="_rauMYDvlEeePyrL5fVHxNw" isWired="false" base_Port="_raos0DvlEeePyrL5fVHxNw"/>
  <UMLRealTime:RTPort xmi:id="_BJ2yUDvmEeePyrL5fVHxNw" base_Port="_BJxSwDvmEeePyrL5fVHxNw"/>
  <UMLRealTime:RTPort xmi:id="_MRFlcDvmEeePyrL5fVHxNw" isWired="false" base_Port="_MRDJMDvmEeePyrL5fVHxNw"/>
  <UMLRTStateMachines:RTState xmi:id="_5hH_ADvoEeePyrL5fVHxNw" base_State="_5hGJ0DvoEeePyrL5fVHxNw"/>
  <UMLRTStateMachines:RTState xmi:id="_evPmADvqEeePyrL5fVHxNw" base_State="_evMisDvqEeePyrL5fVHxNw"/>
  <UMLRealTime:RTPort xmi:id="_17jUkDvqEeePyrL5fVHxNw" isWired="false" base_Port="_17g4UDvqEeePyrL5fVHxNw"/>
  <UMLRTStateMachines:RTState xmi:id="_T7Sh8DvvEeePyrL5fVHxNw" base_State="_T7QswDvvEeePyrL5fVHxNw"/>
  <RTCppProperties:CapsuleProperties xmi:id="_kMQSMDvzEeePyrL5fVHxNw" implementationPreface="#include &lt;stdio.h>&#xD;&#xA;#include &lt;iostream>&#xD;&#xA;using namespace std;&#xD;&#xA;" base_Class="_JK_5IDs0Eee4vrzjGIvOwQ"/>
  <UMLRealTime:RTPort xmi:id="_qi-6ADwPEeez78_2BqgPcw" base_Port="_qi3lQDwPEeez78_2BqgPcw"/>
  <UMLRealTime:RTConnector xmi:id="_vFNIADwPEeez78_2BqgPcw" base_Connector="_vFI2kDwPEeez78_2BqgPcw"/>
  <UMLRealTime:RTPort xmi:id="_1_c4AEAaEeecSdgC5rjddw" isPublish="true" isWired="false" base_Port="_144V8EAaEeecSdgC5rjddw"/>
  <UMLRealTime:RTPort xmi:id="_mtJWIEAbEeecSdgC5rjddw" isWired="false" base_Port="_ms43cEAbEeecSdgC5rjddw"/>
  <UMLRealTime:RTPort xmi:id="_Uo-woEAcEeecSdgC5rjddw" isWired="false" base_Port="_UouR8EAcEeecSdgC5rjddw"/>
  <UMLRTStateMachines:RTState xmi:id="_ZzzPsEAcEeecSdgC5rjddw" base_State="_ZzlNQEAcEeecSdgC5rjddw"/>
  <UMLRTStateMachines:RTState xmi:id="_smSeUEAcEeecSdgC5rjddw" base_State="_smFqAEAcEeecSdgC5rjddw"/>
  <UMLRealTime:RTConnector xmi:id="_oJRHIEAhEeecSdgC5rjddw" base_Connector="_oJDrwEAhEeecSdgC5rjddw"/>
  <UMLRealTime:RTPort xmi:id="_OpAVUECXEeeKEZi9P2TNWQ" isWired="false" base_Port="_Oo8q8ECXEeeKEZi9P2TNWQ"/>
  <UMLRTStateMachines:RTState xmi:id="_sSzEsECXEeeKEZi9P2TNWQ" base_State="_sSwBYECXEeeKEZi9P2TNWQ"/>
  <UMLRealTime:RTPort xmi:id="_-5iXkETPEeem9u7KRr3TyA" isWired="false" base_Port="_-4kuQETPEeem9u7KRr3TyA"/>
  <UMLRealTime:RTPort xmi:id="_wIU8UETrEeem9u7KRr3TyA" base_Port="_wEmS4ETrEeem9u7KRr3TyA"/>
  <UMLRealTime:RTConnector xmi:id="_Or-r4ETsEeem9u7KRr3TyA" base_Connector="_Od3XYETsEeem9u7KRr3TyA"/>
  <ActionLanguage:TextualRepresentation xmi:id="_zVSOUEt_EeeD4eyKVO2S_Q" base_Comment="_y-eQ0Et_EeeD4eyKVO2S_Q" language="org.eclipse.papyrus.uml.textedit.state.xtext.UmlState"/>
  <UMLRTStateMachines:RTState xmi:id="_5YYYEGftEee-Kre0NmQF5w" base_State="_5YWi4GftEee-Kre0NmQF5w"/>
  <RTCppProperties:CapsuleProperties xmi:id="_q_ffkGfwEee-Kre0NmQF5w" headerPreface="&#xA;#include &quot;Zombie.hh&quot;&#xA;#include &quot;external_resources/opencv/sources/modules/core/include/opencv2/core.hpp&quot;&#xA;#include &quot;external_resources/opencv/sources/modules/highgui/include/opencv2/highgui.hpp&quot;&#xA;#include &quot;external_resources/opencv/sources/modules/imgcodecs/include/opencv2/imgcodecs.hpp&quot;&#xA;#include &quot;external_resources/opencv/sources/modules/imgproc/include/opencv2/imgproc.hpp&quot;&#xA;using namespace cv;" implementationPreface="&#xA;#include &quot;Zombie.hh&quot;&#xA;#include &quot;external_resources/opencv/sources/modules/core/include/opencv2/core.hpp&quot;&#xA;#include &quot;external_resources/opencv/sources/modules/highgui/include/opencv2/highgui.hpp&quot;&#xA;#include &quot;external_resources/opencv/sources/modules/imgcodecs/include/opencv2/imgcodecs.hpp&quot;&#xA;#include &quot;external_resources/opencv/sources/modules/imgproc/include/opencv2/imgproc.hpp&quot;&#xA;using namespace cv;" base_Class="_LFgVYDvhEeePyrL5fVHxNw"/>
  <RTCppProperties:AttributeProperties xmi:id="_XzrVgGfxEee-Kre0NmQF5w" type="Mat" base_Property="_XzqHYGfxEee-Kre0NmQF5w"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_Xrw6MGfyEee-Kre0NmQF5w" base_Pseudostate="_XrsowGfyEee-Kre0NmQF5w"/>
  <RTCppProperties:PassiveClassProperties xmi:id="_lLmVQHIrEeeJYpdF89kMeA" headerPreface="#include &lt;vector>&#xA;#include &lt;iostream>&#xA;using namespace std;&#xA;" base_Class="_hizCkHIrEeeJYpdF89kMeA" publicDeclarations="friend ostream &amp; operator&lt;&lt;(ostream &amp; os, const Vector &amp; v)&#xA;{&#xA;    os &lt;&lt; &quot;Vector { &quot;;&#xA;    int len = v.zVector.size();&#xA;    int i = 0;&#xA;    for (std::vector&lt;Zombie>::const_iterator it = v.zVector.begin(); it != v.zVector.end(); it++, i++)&#xA;    {&#xA;        os &lt;&lt; *it;&#xA;        if (i &lt; len - 1) os &lt;&lt; &quot;, &quot;;&#xA;    }&#xA;    os &lt;&lt; &quot; }&quot;;&#xA;    return os;&#xA;}&#xA;"/>
  <RTCppProperties:AttributeProperties xmi:id="_bl2GgHIsEeeJYpdF89kMeA" type="std::vector&lt;Zombie>" base_Property="_sgoCEHIrEeeJYpdF89kMeA"/>
  <UMLRealTime:Capsule xmi:id="_FX58QHL-EeeXs9sY7gI7cA" base_Class="_FQa0MHL-EeeXs9sY7gI7cA"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_x3x3IHbEEeeXs9sY7gI7cA" base_Pseudostate="_x3uMwHbEEeeXs9sY7gI7cA"/>
  <UMLRTStateMachines:RTState xmi:id="_x4C84HbEEeeXs9sY7gI7cA" base_State="_x4BHsHbEEeeXs9sY7gI7cA"/>
  <UMLRTStateMachines:RTRegion xmi:id="_x4KRoHbEEeeXs9sY7gI7cA" base_Region="_x3rJcHbEEeeXs9sY7gI7cA"/>
  <UMLRTStateMachines:RTStateMachine xmi:id="_x5Rr8HbEEeeXs9sY7gI7cA" base_StateMachine="_x3cf8HbEEeeXs9sY7gI7cA"/>
  <UMLRTStateMachines:RTState xmi:id="_Xh3BYHbGEeeXs9sY7gI7cA" base_State="_Xh0lIHbGEeeXs9sY7gI7cA"/>
  <UMLRealTime:RTPort xmi:id="_yYr54HbGEeeXs9sY7gI7cA" isPublish="false" isWired="true" base_Port="_yYpdoHbGEeeXs9sY7gI7cA"/>
  <UMLRealTime:RTPort xmi:id="_jEkSwHbKEeeXs9sY7gI7cA" isPublish="false" isWired="false" base_Port="_jEhPcHbKEeeXs9sY7gI7cA"/>
  <UMLRTStateMachines:RTState xmi:id="_IVXHYHbZEeeXs9sY7gI7cA" base_State="_IVV5QHbZEeeXs9sY7gI7cA"/>
  <UMLRealTime:RTPort xmi:id="_vEcx4HbaEeeXs9sY7gI7cA" isPublish="false" isWired="true" base_Port="_vEaVoHbaEeeXs9sY7gI7cA"/>
  <UMLRealTime:CapsulePart xmi:id="_tlCnEHb6EeeKIIc_475P2A" base_Property="_tk-VoHb6EeeKIIc_475P2A"/>
  <UMLRealTime:RTPort xmi:id="_57V1YHb6EeeKIIc_475P2A" isNotification="false" isPublish="false" isWired="true" registration="Automatic" registrationOverride="" base_Port="_57VOUHb6EeeKIIc_475P2A"/>
  <UMLRealTime:RTPort xmi:id="_7pO6kHb6EeeKIIc_475P2A" isNotification="false" isPublish="false" isWired="true" registration="Automatic" registrationOverride="" base_Port="_7pOTgHb6EeeKIIc_475P2A"/>
  <UMLRealTime:RTConnector xmi:id="_I8sUsXb7EeeKIIc_475P2A" base_Connector="_I8p4cHb7EeeKIIc_475P2A"/>
  <UMLRealTime:RTConnector xmi:id="_JzO7Inb7EeeKIIc_475P2A" base_Connector="_JzNF8Hb7EeeKIIc_475P2A"/>
  <UMLRealTime:RTPort xmi:id="_IaBlIHb-EeeKIIc_475P2A" isPublish="false" isWired="false" base_Port="_IZ8FkHb-EeeKIIc_475P2A"/>
  <UMLRealTime:Capsule xmi:id="_fFBTIHovEeesmeF6iS6c6Q" base_Class="_fE_eAHovEeesmeF6iS6c6Q"/>
  <UMLRealTime:ProtocolContainer xmi:id="_fFBTIXovEeesmeF6iS6c6Q" base_Package="_fE_d83ovEeesmeF6iS6c6Q"/>
  <UMLRealTime:RTMessageSet xmi:id="_fFBTInovEeesmeF6iS6c6Q" base_Interface="_fE_d93ovEeesmeF6iS6c6Q"/>
  <UMLRealTime:RTMessageSet xmi:id="_fFBTI3ovEeesmeF6iS6c6Q" base_Interface="_fE_d-HovEeesmeF6iS6c6Q" rtMsgKind="out"/>
  <UMLRealTime:RTMessageSet xmi:id="_fFBTJHovEeesmeF6iS6c6Q" base_Interface="_fE_d_XovEeesmeF6iS6c6Q" rtMsgKind="inOut"/>
  <UMLRealTime:Protocol xmi:id="_fFBTJXovEeesmeF6iS6c6Q" base_Collaboration="_fE_d9HovEeesmeF6iS6c6Q"/>
  <UMLRealTime:RTPort xmi:id="_fFBTJnovEeesmeF6iS6c6Q" isNotification="true" isPublish="true" isWired="false" base_Port="_fE_eAXovEeesmeF6iS6c6Q"/>
  <UMLRealTime:RTPort xmi:id="_fFBTJ3ovEeesmeF6iS6c6Q" isWired="false" base_Port="_fE_eBHovEeesmeF6iS6c6Q"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_fFBTKHovEeesmeF6iS6c6Q" base_Pseudostate="_fE_eE3ovEeesmeF6iS6c6Q"/>
  <UMLRTStateMachines:RTState xmi:id="_fFBTKXovEeesmeF6iS6c6Q" base_State="_fE_eFHovEeesmeF6iS6c6Q"/>
  <UMLRTStateMachines:RTRegion xmi:id="_fFBTKnovEeesmeF6iS6c6Q" base_Region="_fE_eB3ovEeesmeF6iS6c6Q"/>
  <UMLRTStateMachines:RTStateMachine xmi:id="_fFBTK3ovEeesmeF6iS6c6Q" base_StateMachine="_fE_eBnovEeesmeF6iS6c6Q"/>
  <RTCppProperties:CapsuleProperties xmi:id="_fFBTLHovEeesmeF6iS6c6Q" headerPreface="#include &quot;Method.hh&quot;&#xA;#include &quot;Socket.hh&quot;&#xA;#include &quot;Serializer.hh&quot;&#xA;#include &quot;Text.hh&quot;&#xA;#include &quot;CLIUtils.hh&quot;&#xA;#include &quot;Config.hh&quot;" base_Class="_fE_eAHovEeesmeF6iS6c6Q" privateDeclarations="Method* method;&#xA;Serializer* serializer;&#xA;std::map&lt;std::string, size_t> capsules;&#xA;std::map&lt;std::string, std::string> capsuleTypes;&#xA;Config config;"/>
  <UMLRealTime:RTPort xmi:id="_fFBTLXovEeesmeF6iS6c6Q" isWired="false" base_Port="_fE_eBXovEeesmeF6iS6c6Q"/>
  <RTCppProperties:CapsuleProperties xmi:id="_fFBTLnovEeesmeF6iS6c6Q" headerPreface="#include &quot;Event.hh&quot;" implementationPreface="" base_Class="_fE_eHXovEeesmeF6iS6c6Q" publicDeclarations="Event event;"/>
  <RTCppProperties:ArtifactProperties xmi:id="_fFB6MHovEeesmeF6iS6c6Q" base_Artifact="_fE_eFnovEeesmeF6iS6c6Q" includeFile="/*&#xA; * Event.hh&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#ifndef EVENT_HH_&#xA;#define EVENT_HH_&#xA;&#xA;#include &lt;map>&#xA;#include &lt;iostream>&#xA;#include &lt;string.h>&#xA;#include &lt;sstream>&#xA;#include &lt;stdio.h>&#xA;#include &lt;stdlib.h>&#xA;#include &lt;vector>&#xA;&#xA;class Event {&#xA;&#xA;public:&#xA;typedef enum {&#xA;&#x9;&#x9;Signal,&#xA;&#x9;&#x9;Method,&#xA;&#x9;&#x9;ActionCode,&#xA;&#x9;&#x9;Transition,&#xA;&#x9;&#x9;State,&#xA;&#x9;&#x9;Capsule,&#xA;&#x9;&#x9;Attribute,&#xA;&#x9;&#x9;Timer,&#xA;&#x9;&#x9;UnknownSource&#xA;&#x9;} EventSource;&#xA;&#xA;&#x9;typedef enum {&#xA;&#x9;&#x9;SendSignal, ReceiveSignal, DeferSignal, RecallSignal, CancelSignal, // Signal events&#xA;&#x9;&#x9;MethodCall,&#xA;&#x9;&#x9;MethodCallReceive,&#xA;&#x9;&#x9;MethodStartExecute,&#xA;&#x9;&#x9;MethodReturn,&#xA;&#x9;&#x9;MethodFailed,&#xA;&#x9;&#x9;MethodReturnReceived, // Method events&#xA;&#x9;&#x9;ActionStart,&#xA;&#x9;&#x9;ActionEnd, // Action code events&#xA;&#x9;&#x9;TransitionStart,&#xA;&#x9;&#x9;TransitionEnd, // Transition events&#xA;&#x9;&#x9;StateEntryStart,&#xA;&#x9;&#x9;StateEntryEnd,&#xA;&#x9;&#x9;StateExitStart,&#xA;&#x9;&#x9;StateExitEnd,&#xA;&#x9;&#x9;StateIdleStart,&#xA;&#x9;&#x9;StateIdleEnd, // State events&#xA;&#x9;&#x9;CapsuleInstantiate,&#xA;&#x9;&#x9;CapsuleFree, // Capsule events&#xA;&#x9;&#x9;AttributeInstantiate,&#xA;&#x9;&#x9;AttributeFree,&#xA;&#x9;&#x9;AttributeChange, // Attribute events&#xA;&#x9;&#x9;TimerStart,&#xA;&#x9;&#x9;TimerSet,&#xA;&#x9;&#x9;TimerCancel,&#xA;&#x9;&#x9;TimerTimeout, // Timer events&#xA;&#x9;&#x9;UnknownKind&#xA;&#x9;} EventKind;&#xA;&#xA;private:&#xA;&#x9;std::string capsuleInstance;&#xA;&#x9;std::string sourceName;&#xA;&#x9;std::string eventId;&#xA;&#x9;long seconds;&#xA;&#x9;long nanoseconds;&#xA;&#x9;EventSource eventSource;&#xA;&#x9;EventKind eventKind;&#xA;&#x9;std::map&lt;std::string, std::string> params;&#xA;&#xA;public:&#xA;&#x9;Event(std::string capsuleInstance = &quot;&quot;, std::string sourceName = &quot;&quot;,&#xA;&#x9;&#x9;&#x9;EventSource eventSource = UnknownSource, EventKind eventKind =&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;UnknownKind, long seconds = 0, long nanoseconds = 0);&#xA;&#x9;const std::string getCapsuleInstance() const;&#xA;&#x9;void setCapsuleInstance(const std::string capsuleInstance);&#xA;&#x9;const std::string getSourceName() const;&#xA;&#x9;void setSourceName(const std::string sourceName);&#xA;&#x9;const EventSource getEventSource() const;&#xA;&#x9;void setEventSource(const Event::EventSource source);&#xA;&#x9;const EventKind getEventKind() const;&#xA;&#x9;void setEventKind(const Event::EventKind kind);&#xA;&#x9;const long getSeconds() const;&#xA;&#x9;const long getNanoseconds() const;&#xA;&#x9;void setTimestamp();&#xA;&#x9;void setTimestamp(const long seconds, const long nanoseconds = 0);&#xA;&#x9;void setSeconds(const long seconds);&#xA;&#x9;void setNanoseconds(const long nanoseconds = 0);&#xA;&#x9;void setEventId(const std::string eventId);&#xA;&#x9;const std::string getEventId() const;&#xA;&#x9;void generateEventId();&#xA;&#x9;const std::map&lt;std::string, std::string> getParams() const;&#xA;&#x9;const std::string getParam(std::string key) const;&#xA;&#x9;void setParams(const std::map&lt;std::string, std::string> params);&#xA;&#x9;void setParam(const std::string key, const std::string value);&#xA;&#x9;void setParam(const std::string key, const int value);&#xA;&#x9;void clearParams();&#xA;};&#xA;&#xA;#endif /* EVENT_HH_ */" sourceFile="/*&#xA; * Event.cc&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#include &quot;Event.hh&quot;&#xA;&#xA;#include &lt;string>&#xA;#include &lt;sstream>&#xA;#include &lt;time.h>&#xA;#include &lt;sys/time.h>&#xA;#include &lt;stdio.h>&#xA;#include &lt;stdlib.h>&#xA;&#xA;Event::Event(std::string capsuleInstance, std::string sourceName,&#xA;&#x9;&#x9;EventSource eventSource, EventKind eventKind, long seconds,&#xA;&#x9;&#x9;long nanoseconds) {&#xA;&#xA;&#x9;this->generateEventId();&#xA;&#x9;this->setCapsuleInstance(capsuleInstance);&#xA;&#x9;this->setSourceName(sourceName);&#xA;&#x9;this->setEventSource(eventSource);&#xA;&#x9;this->setEventKind(eventKind);&#xA;}&#xA;&#xA;const std::string Event::getCapsuleInstance() const {&#xA;&#x9;return this->capsuleInstance;&#xA;}&#xA;&#xA;void Event::setCapsuleInstance(const std::string capsuleInstance) {&#xA;&#x9;this->capsuleInstance = capsuleInstance;&#xA;}&#xA;&#xA;const std::string Event::getSourceName() const {&#xA;&#x9;return this->sourceName;&#xA;}&#xA;&#xA;void Event::setSourceName(const std::string sourceName) {&#xA;&#x9;this->sourceName = sourceName;&#xA;}&#xA;&#xA;const Event::EventSource Event::getEventSource() const {&#xA;&#x9;return this->eventSource;&#xA;}&#xA;&#xA;void Event::setEventSource(const Event::EventSource source) {&#xA;&#x9;this->eventSource = source;&#xA;}&#xA;&#xA;const Event::EventKind Event::getEventKind() const {&#xA;&#x9;return this->eventKind;&#xA;}&#xA;&#xA;void Event::setEventKind(const Event::EventKind kind) {&#xA;&#x9;this->eventKind = kind;&#xA;}&#xA;&#xA;const long Event::getSeconds() const {&#xA;&#x9;return this->seconds;&#xA;}&#xA;&#xA;const long Event::getNanoseconds() const {&#xA;&#x9;return this->nanoseconds;&#xA;}&#xA;&#xA;void Event::setTimestamp() {&#xA;&#xA;&#x9;long seconds, nanoseconds;&#xA;&#xA;&#x9;struct timeval tp;&#xA;&#x9;gettimeofday(&amp;tp, NULL);&#xA;&#xA;&#x9;seconds = tp.tv_sec;&#xA;&#x9;nanoseconds = tp.tv_usec * 1000;&#xA;&#xA;&#x9;this->setTimestamp(seconds, nanoseconds);&#xA;&#xA;}&#xA;&#xA;void Event::setTimestamp(const long seconds, const long nanoseconds) {&#xA;&#x9;setSeconds(seconds);&#xA;&#x9;this->setNanoseconds(nanoseconds);&#xA;&#x9;this->seconds = seconds;&#xA;&#x9;this->nanoseconds = nanoseconds;&#xA;}&#xA;&#xA;void Event::setSeconds(const long seconds) {&#xA;&#x9;this->seconds = seconds;&#xA;}&#xA;void Event::setNanoseconds(const long nanoseconds) {&#xA;&#x9;this->nanoseconds = nanoseconds;&#xA;}&#xA;&#xA;const std::string Event::getEventId() const {&#xA;&#x9;return this->eventId;&#xA;}&#xA;&#xA;void Event::setEventId(const std::string eventId) {&#xA;&#x9;this->eventId = eventId;&#xA;}&#xA;&#xA;void Event::generateEventId() {&#xA;&#xA;&#x9;long seconds, nanoseconds;&#xA;&#xA;&#x9;struct timeval tp;&#xA;&#x9;gettimeofday(&amp;tp, NULL);&#xA;&#xA;&#x9;seconds = tp.tv_sec;&#xA;&#x9;nanoseconds = tp.tv_usec * 1000;&#xA;&#xA;&#x9;std::stringstream ss;&#xA;&#x9;int r;&#xA;&#x9;r = random();&#xA;&#xA;&#x9;ss &lt;&lt; seconds &lt;&lt; nanoseconds &lt;&lt; r;&#xA;&#x9;this->eventId = ss.str();&#xA;}&#xA;&#xA;const std::map&lt;std::string, std::string> Event::getParams() const {&#xA;&#x9;return params;&#xA;}&#xA;&#xA;const std::string Event::getParam(std::string key) const {&#xA;&#x9;bool n = this->params.count(key);&#xA;&#x9;return (n) ? this->params.at(key) : &quot;&quot;;&#xA;}&#xA;&#xA;void Event::setParams(const std::map&lt;std::string, std::string> params) {&#xA;&#x9;this->params = params;&#xA;}&#xA;&#xA;void Event::setParam(const std::string key, const std::string value) {&#xA;&#x9;if (key.length() >= 1)&#xA;&#x9;&#x9;this->params[key] = value;&#xA;}&#xA;&#xA;void Event::setParam(const std::string key, const int value) {&#xA;&#x9;std::stringstream v;&#xA;&#x9;v &lt;&lt; value;&#xA;&#x9;this->setParam(key, v.str());&#xA;}&#xA;&#xA;void Event::clearParams() {&#xA;&#x9;this->params.clear();&#xA;}"/>
  <RTCppProperties:ArtifactProperties xmi:id="_fFB6MXovEeesmeF6iS6c6Q" base_Artifact="_fE_eF3ovEeesmeF6iS6c6Q" includeFile="/*&#xA; * CLIUtils.hh&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#ifndef CLIUTILS_HH_&#xA;#define CLIUTILS_HH_&#xA;&#xA;#include&lt;string>&#xA;#include&lt;vector>&#xA;&#xA;namespace CLIUtils {&#xA;&#xA;std::string trim(std::string str);&#xA;std::vector&lt;std::string> tokenizeCommand(const std::string cmd);&#xA;&#xA;}&#xA;&#xA;&#xA;&#xA;#endif /* CLIUTILS_HH_ */" sourceFile="/*&#xA; * CLIUtils.cc&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#include &quot;CLIUtils.hh&quot;&#xA;&#xA;#include&lt;string>&#xA;#include&lt;vector>&#xA;&#xA;namespace CLIUtils {&#xA;&#xA;std::string trim(std::string str) {&#xA;&#x9;size_t strBegin = str.find_first_not_of(&quot; \n\r\t&quot;);&#xA;&#x9;if (strBegin == std::string::npos)&#xA;&#x9;&#x9;return &quot;&quot;; // no content&#xA;&#xA;&#x9;size_t strEnd = str.find_last_not_of(&quot; \n\r\t&quot;);&#xA;&#x9;size_t strRange = strEnd - strBegin + 1;&#xA;&#x9;return str.substr(strBegin, strRange);&#xA;}&#xA;&#xA;std::vector&lt;std::string> tokenizeCommand(const std::string cmd) {&#xA;&#x9;std::vector&lt;std::string> cmdTokens;&#xA;&#xA;&#x9;std::string command = trim(cmd);&#xA;&#xA;&#x9;if (command.length() == 0)&#xA;&#x9;&#x9;return cmdTokens;&#xA;&#xA;&#x9;std::string tempS = &quot;&quot;;&#xA;&#x9;bool newVar = false;&#xA;&#x9;bool quotation = false;&#xA;&#xA;&#x9;for (unsigned int i = 0; i &lt; command.length(); i++) {&#xA;&#xA;&#x9;&#x9;char c = command[i];&#xA;&#x9;&#x9;bool isSpaceOrEOL = (c == ' ' || c == '\n');&#xA;&#xA;&#x9;&#x9;if (isSpaceOrEOL) {&#xA;&#xA;&#x9;&#x9;&#x9;if (!newVar)&#xA;&#x9;&#x9;&#x9;&#x9;continue;&#xA;&#xA;&#x9;&#x9;&#x9;if (!quotation) {&#xA;&#x9;&#x9;&#x9;&#x9;newVar = false;&#xA;&#x9;&#x9;&#x9;&#x9;cmdTokens.push_back(trim(tempS));&#xA;&#x9;&#x9;&#x9;&#x9;tempS = &quot;&quot;;&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;tempS = tempS + c;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;} else if (c == '&quot;') {&#xA;&#x9;&#x9;&#x9;if (!quotation) {&#xA;&#x9;&#x9;&#x9;&#x9;// open a quotation&#xA;&#x9;&#x9;&#x9;&#x9;quotation = true;&#xA;&#x9;&#x9;&#x9;&#x9;if (newVar) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;cmdTokens.push_back(trim(tempS));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempS = &quot;&quot;;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;newVar = true;&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;quotation = false;&#xA;&#x9;&#x9;&#x9;&#x9;newVar = false;&#xA;&#x9;&#x9;&#x9;&#x9;cmdTokens.push_back(trim(tempS));&#xA;&#x9;&#x9;&#x9;&#x9;tempS = &quot;&quot;;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;newVar = true;&#xA;&#x9;&#x9;&#x9;tempS = tempS + c;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;if (newVar)&#xA;&#x9;&#x9;cmdTokens.push_back(trim(tempS));&#xA;&#xA;&#x9;return cmdTokens;&#xA;}&#xA;&#xA;}&#xA;"/>
  <RTCppProperties:ArtifactProperties xmi:id="_fFB6MnovEeesmeF6iS6c6Q" base_Artifact="_fE_eGHovEeesmeF6iS6c6Q" includeFile="/*&#xA; * Serializer.hh&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#ifndef SERIALIZER_HH_&#xA;#define SERIALIZER_HH_&#xA;&#xA;#include &lt;map>&#xA;#include &lt;string>&#xA;#include &quot;Event.hh&quot;&#xA;&#xA;class Serializer {&#xA;&#xA;public:&#xA;&#x9;Serializer();&#xA;&#x9;virtual ~Serializer();&#xA;&#x9;virtual void configure(std::map&lt;std::string, std::string> configList) = 0;&#xA;&#x9;virtual const std::string serialize(const Event event) const = 0;&#xA;&#x9;virtual Event parse(const std::string data) const = 0;&#xA;&#x9;virtual const std::string getConfig(&#xA;&#x9;&#x9;&#x9;std::map&lt;std::string, std::string> configList,&#xA;&#x9;&#x9;&#x9;std::string key) const;&#xA;};&#xA;&#xA;#endif /* SERIALIZER_HH_ */" sourceFile="/*&#xA; * Serializer.cc&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#include &quot;Serializer.hh&quot;&#xA;&#xA;Serializer::Serializer() {&#xA;}&#xA;&#xA;Serializer::~Serializer() {&#xA;}&#xA;&#xA;const std::string Serializer::getConfig(&#xA;&#x9;&#x9;std::map&lt;std::string, std::string> configList, std::string key) const {&#xA;&#x9;bool n = configList.count(key);&#xA;&#x9;return (n) ? configList.at(key) : &quot;&quot;;&#xA;}"/>
  <RTCppProperties:ArtifactProperties xmi:id="_fFB6M3ovEeesmeF6iS6c6Q" base_Artifact="_fE_eGXovEeesmeF6iS6c6Q" includeFile="/*&#xA; * Method.hh&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#ifndef METHOD_HH_&#xA;#define METHOD_HH_&#xA;&#xA;#include &lt;map>&#xA;#include &lt;string>&#xA;&#xA;class Method {&#xA;&#xA;public:&#xA;&#x9;Method();&#xA;&#x9;virtual ~Method();&#xA;&#x9;virtual void configure(std::map&lt;std::string, std::string> configList) = 0;&#xA;&#x9;virtual const bool canConnect() const;&#xA;&#x9;virtual int connect() = 0;&#xA;&#x9;virtual void disconnect() = 0;&#xA;&#x9;virtual std::string read() = 0;&#xA;&#x9;virtual void sendData(std::string) = 0;&#xA;&#x9;virtual const std::string getConfig(&#xA;&#x9;&#x9;&#x9;std::map&lt;std::string, std::string> configList,&#xA;&#x9;&#x9;&#x9;std::string key) const;&#xA;};&#xA;&#xA;#endif /* METHOD_HH_ */&#xA;" sourceFile="/*&#xA; * Method.cc&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#include &quot;Method.hh&quot;&#xA;#include &lt;stdio.h>&#xA;&#xA;Method::Method() {&#xA;}&#xA;&#xA;Method::~Method() {&#xA;}&#xA;&#xA;const bool Method::canConnect() const {&#xA;&#x9;return false;&#xA;}&#xA;&#xA;const std::string Method::getConfig(&#xA;&#x9;&#x9;std::map&lt;std::string, std::string> configList, std::string key) const {&#xA;&#x9;bool n = configList.count(key);&#xA;&#x9;return (n) ? configList.at(key) : &quot;&quot;;&#xA;}"/>
  <RTCppProperties:ArtifactProperties xmi:id="_fFB6NHovEeesmeF6iS6c6Q" base_Artifact="_fE_eGnovEeesmeF6iS6c6Q" includeFile="/*&#xA; * Text.hh&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#ifndef TEXT_HH_&#xA;#define TEXT_HH_&#xA;&#xA;#include &quot;Serializer.hh&quot;&#xA;#include &quot;Event.hh&quot;&#xA;#include &lt;string>&#xA;#include &lt;stdlib.h>&#xA;#include &lt;unistd.h>&#xA;&#xA;class Text: public Serializer {&#xA;&#xA;private:&#xA;&#x9;std::string format;&#xA;&#xA;&#x9;// separators&#xA;&#x9;char separator;&#xA;&#x9;char paramSeparator;&#xA;&#x9;char keyValueSeparator;&#xA;&#xA;&#x9;std::vector&lt;std::string> fields;&#xA;&#x9;unsigned int fieldNumber;&#xA;&#x9;const std::vector&lt;std::string> split(const std::string data,&#xA;&#x9;&#x9;&#x9;const char separator) const;&#xA;&#xA;protected:&#xA;&#x9;const std::string getField(const std::string field,&#xA;&#x9;&#x9;&#x9;const Event&amp; event) const;&#xA;&#x9;void setField(const std::string field, const std::string value,&#xA;&#x9;&#x9;&#x9;Event&amp; event) const;&#xA;&#xA;public:&#xA;&#x9;Text();&#xA;&#x9;virtual ~Text();&#xA;&#x9;virtual void configure(std::map&lt;std::string, std::string> configList);&#xA;&#x9;virtual const std::string serialize(const Event event) const;&#xA;&#x9;const std::string serializeParams(const Event event) const;&#xA;&#x9;virtual Event parse(const std::string data) const;&#xA;&#x9;void parseParameters(Event&amp; event, const std::string data) const;&#xA;&#x9;void setFormat(const std::string format);&#xA;&#x9;const std::string getFormat() const;&#xA;&#x9;void setSeparator(const char separator);&#xA;&#x9;void setParamSeparator(const char paramSeparator);&#xA;&#x9;void setKeyValueSeparator(const char keyValueSeparator);&#xA;};&#xA;&#xA;#endif /* TEXT_HH_ */" sourceFile="/*&#xA; * Text.cc&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#include &quot;Text.hh&quot;&#xA;&#xA;#include &quot;Event.hh&quot;&#xA;&#xA;#include &lt;string.h>&#xA;#include &lt;sstream>&#xA;#include &lt;iostream>&#xA;#include &lt;sstream>&#xA;#include &lt;stdio.h>&#xA;#include &lt;stdlib.h>&#xA;#include &lt;vector>&#xA;#include &lt;algorithm>&#xA;&#xA;Text::Text() :&#xA;&#x9;&#x9;Serializer() {&#xA;&#x9;this->setSeparator('|');&#xA;&#x9;this->setParamSeparator(';');&#xA;&#x9;this->setKeyValueSeparator(':');&#xA;&#x9;this->setFormat(&#xA;&#x9;&#x9;&#x9;&quot;eventId|sourceName|eventSource|eventKind|seconds|nanoseconds|params&quot;);&#xA;}&#xA;&#xA;Text::~Text() {&#xA;}&#xA;&#xA;void Text::configure(std::map&lt;std::string, std::string> configList) {&#xA;&#x9;std::string separator, paramSeparator, keyValueSeparator, format;&#xA;&#xA;&#x9;separator = this->getConfig(configList, &quot;text.separator&quot;);&#xA;&#x9;paramSeparator = this->getConfig(configList, &quot;text.paramSeparator&quot;);&#xA;&#x9;keyValueSeparator = this->getConfig(configList, &quot;text.keyValueSeparator&quot;);&#xA;&#x9;format = this->getConfig(configList, &quot;text.format&quot;);&#xA;&#xA;&#x9;if (!separator.empty())&#xA;&#x9;&#x9;this->setSeparator(separator[0]);&#xA;&#xA;&#x9;if (!paramSeparator.empty())&#xA;&#x9;&#x9;this->setParamSeparator(paramSeparator[0]);&#xA;&#xA;&#x9;if (!keyValueSeparator.empty())&#xA;&#x9;&#x9;this->setKeyValueSeparator(keyValueSeparator[0]);&#xA;&#xA;&#x9;if (!format.empty())&#xA;&#x9;&#x9;this->setFormat(format);&#xA;&#xA;}&#xA;&#xA;void Text::setFormat(const std::string format) {&#xA;&#x9;this->format = format;&#xA;&#x9;std::vector&lt;std::string> v = this->split(format, this->separator);&#xA;&#xA;&#x9;if (!v.size())&#xA;&#x9;&#x9;return;&#xA;&#xA;&#x9;this->fields.clear();&#xA;&#x9;this->fields = v;&#xA;&#x9;this->fieldNumber = this->fields.size();&#xA;}&#xA;&#xA;const std::string Text::getFormat() const {&#xA;&#x9;return this->format;&#xA;}&#xA;&#xA;void Text::setSeparator(const char separator) {&#xA;&#x9;this->separator = separator;&#xA;}&#xA;&#xA;void Text::setParamSeparator(const char paramSeparator) {&#xA;&#x9;this->paramSeparator = paramSeparator;&#xA;}&#xA;&#xA;void Text::setKeyValueSeparator(const char keyValueSeparator) {&#xA;&#x9;this->keyValueSeparator = keyValueSeparator;&#xA;}&#xA;&#xA;const std::string Text::serialize(Event event) const {&#xA;&#xA;&#x9;char fieldSeparator = this->separator;&#xA;&#xA;// results&#xA;&#x9;std::stringstream out;&#xA;&#xA;&#x9;std::vector&lt;std::string>::iterator it1;&#xA;&#x9;std::vector&lt;std::string> v = this->fields;&#xA;&#xA;&#x9;for (it1 = v.begin(); it1 != v.end(); ++it1) {&#xA;&#x9;&#x9;std::string field = *it1;&#xA;&#x9;&#x9;std::transform(field.begin(), field.end(), field.begin(), ::tolower);&#xA;&#x9;&#x9;out &lt;&lt; this->getField(field, event) &lt;&lt; fieldSeparator;&#xA;&#x9;}&#xA;&#xA;&#x9;return out.str();&#xA;}&#xA;&#xA;const std::string Text::serializeParams(Event event) const {&#xA;&#xA;// results&#xA;&#x9;std::stringstream out;&#xA;&#xA;// params&#xA;&#x9;std::map&lt;std::string, std::string>::const_iterator it2;&#xA;&#x9;std::map&lt;std::string, std::string> params = event.getParams();&#xA;&#xA;&#x9;if (params.empty())&#xA;&#x9;&#x9;return out.str();&#xA;&#xA;&#x9;it2 = params.begin();&#xA;&#x9;out &lt;&lt; it2->first &lt;&lt; this->keyValueSeparator &lt;&lt; it2->second;&#xA;&#x9;++it2;&#xA;&#xA;&#x9;for (; it2 != params.end(); ++it2) {&#xA;&#x9;&#x9;out &lt;&lt; this->paramSeparator &lt;&lt; it2->first &lt;&lt; this->keyValueSeparator&#xA;&#x9;&#x9;&#x9;&#x9;&lt;&lt; it2->second;&#xA;&#x9;}&#xA;&#xA;&#x9;return out.str();&#xA;}&#xA;&#xA;Event Text::parse(const std::string data) const {&#xA;&#xA;&#x9;char fieldSeparator = this->separator;&#xA;&#xA;&#x9;std::vector&lt;std::string> values = this->split(data, fieldSeparator);&#xA;&#x9;Event event;&#xA;&#xA;&#x9;if (values.size() &lt; fieldNumber) {&#xA;&#x9;&#x9;std::cout &lt;&lt; &quot;Error in parsing event stream, only &quot; &lt;&lt; values.size()&#xA;&#x9;&#x9;&#x9;&#x9;&lt;&lt; &quot; are parsed \n&quot;;&#xA;&#x9;&#x9;return event;&#xA;&#x9;}&#xA;&#xA;&#x9;std::vector&lt;std::string>::iterator it;&#xA;&#x9;std::vector&lt;std::string> v = this->fields;&#xA;&#x9;int i = 0;&#xA;&#xA;&#x9;for (it = v.begin(); it != v.end(); ++it) {&#xA;&#x9;&#x9;std::string field = *it;&#xA;&#x9;&#x9;std::transform(field.begin(), field.end(), field.begin(), ::tolower);&#xA;&#x9;&#x9;this->setField(field, values[i], event);&#xA;&#x9;&#x9;i++;&#xA;&#x9;}&#xA;&#xA;&#x9;return event;&#xA;}&#xA;&#xA;void Text::parseParameters(Event&amp; event, const std::string data) const {&#xA;&#xA;&#x9;std::vector&lt;std::string> v = this->split(data, this->paramSeparator);&#xA;&#x9;std::string temp;&#xA;&#xA;&#x9;if (v.size() == 0)&#xA;&#x9;&#x9;return;&#xA;&#xA;&#x9;event.clearParams();&#xA;&#xA;&#x9;for (unsigned i = 0; i &lt; v.size(); i++) {&#xA;&#xA;&#x9;&#x9;std::string::size_type sepIndex = 0;&#xA;&#x9;&#x9;std::string key, value;&#xA;&#xA;&#x9;&#x9;temp = v[i];&#xA;&#xA;&#x9;&#x9;sepIndex = temp.find(this->keyValueSeparator, 0);&#xA;&#x9;&#x9;key = temp.substr(0, sepIndex);&#xA;&#x9;&#x9;value = temp.substr(sepIndex + 1, temp.length());&#xA;&#xA;&#x9;&#x9;event.setParam(key, value);&#xA;&#xA;&#x9;}&#xA;}&#xA;&#xA;const std::vector&lt;std::string> Text::split(const std::string data,&#xA;&#x9;&#x9;const char separator) const {&#xA;&#xA;&#x9;std::vector&lt;std::string> v;&#xA;&#x9;std::string temp = &quot;&quot;;&#xA;&#x9;bool newField = false;&#xA;&#xA;&#x9;for (unsigned int i = 0; i &lt; data.length(); i++) {&#xA;&#x9;&#x9;if (data[i] == separator) {&#xA;&#x9;&#x9;&#x9;newField = false;&#xA;&#x9;&#x9;&#x9;v.push_back(temp);&#xA;&#x9;&#x9;&#x9;temp = &quot;&quot;;&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;temp = temp + (data[i]);&#xA;&#x9;&#x9;&#x9;newField = true;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;if (newField)&#xA;&#x9;&#x9;v.push_back(temp);&#xA;&#xA;&#x9;return v;&#xA;}&#xA;&#xA;// The functions below have to be overriden when extending the observer&#xA;const std::string Text::getField(const std::string field,&#xA;&#x9;&#x9;const Event&amp; event) const {&#xA;&#xA;&#x9;std::stringstream ss; // for conversion purpose&#xA;&#xA;&#x9;if (field == &quot;eventid&quot;)&#xA;&#x9;&#x9;return event.getEventId();&#xA;&#x9;else if (field == &quot;sourcename&quot;)&#xA;&#x9;&#x9;return event.getSourceName();&#xA;&#x9;else if (field == &quot;capsuleinstance&quot;)&#xA;&#x9;&#x9;return event.getCapsuleInstance();&#xA;&#x9;else if (field == &quot;eventsource&quot;) {&#xA;&#x9;&#x9;ss &lt;&lt; event.getEventSource();&#xA;&#x9;&#x9;return ss.str();&#xA;&#x9;} else if (field == &quot;eventkind&quot;) {&#xA;&#x9;&#x9;ss &lt;&lt; event.getEventKind();&#xA;&#x9;&#x9;return ss.str();&#xA;&#x9;} else if (field == &quot;seconds&quot;) {&#xA;&#x9;&#x9;ss &lt;&lt; event.getSeconds();&#xA;&#x9;&#x9;return ss.str();&#xA;&#x9;} else if (field == &quot;nanoseconds&quot;) {&#xA;&#x9;&#x9;ss &lt;&lt; event.getNanoseconds();&#xA;&#x9;&#x9;return ss.str();&#xA;&#x9;} else if (field == &quot;params&quot;) {&#xA;&#x9;&#x9;return this->serializeParams(event);&#xA;&#x9;}&#xA;&#xA;&#x9;return &quot;&quot;;&#xA;}&#xA;&#xA;void Text::setField(const std::string field, const std::string value,&#xA;&#x9;&#x9;Event&amp; event) const {&#xA;&#xA;&#x9;std::stringstream ss; // for conversion purpose&#xA;&#xA;&#x9;if (field == &quot;eventid&quot;)&#xA;&#x9;&#x9;event.setEventId(value);&#xA;&#x9;else if (field == &quot;sourcename&quot;)&#xA;&#x9;&#x9;event.setSourceName(value);&#xA;&#x9;else if (field == &quot;eventsource&quot;) {&#xA;&#x9;&#x9;event.setEventSource((Event::EventSource) (atoi(value.c_str())));&#xA;&#x9;} else if (field == &quot;eventkind&quot;) {&#xA;&#x9;&#x9;event.setEventKind((Event::EventKind) (atoi(value.c_str())));&#xA;&#x9;} else if (field == &quot;seconds&quot;) {&#xA;&#x9;&#x9;event.setSeconds(atol(value.c_str()));&#xA;&#x9;} else if (field == &quot;nanoseconds&quot;) {&#xA;&#x9;&#x9;event.setNanoseconds(atol(value.c_str()));&#xA;&#x9;} else if (field == &quot;params&quot;) {&#xA;&#x9;&#x9;this->parseParameters(event, value);&#xA;&#x9;}&#xA;}"/>
  <RTCppProperties:ArtifactProperties xmi:id="_fFB6NXovEeesmeF6iS6c6Q" base_Artifact="_fE_eG3ovEeesmeF6iS6c6Q" includeFile="/*&#xA; * Socket.hh&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#ifndef SOCKET_HH_&#xA;#define SOCKET_HH_&#xA;&#xA;#include &lt;arpa/inet.h>&#xA;#include &quot;Method.hh&quot;&#xA;#include &lt;netinet/in.h>&#xA;#include &lt;sys/select.h>&#xA;#include &lt;map>&#xA;#include &lt;string>&#xA;&#xA;class Socket: public Method {&#xA;&#xA;private:&#xA;&#x9;int port;&#xA;&#x9;std::string address;&#xA;&#xA;&#x9;fd_set master;    // master file descriptor list&#xA;&#x9;fd_set read_fds;  // temp file descriptor list for select()&#xA;&#x9;int fdmax;        // maximum file descriptor number&#xA;&#xA;&#x9;int listener;     // listening socket descriptor&#xA;&#x9;struct sockaddr_storage remoteaddr; // client address&#xA;&#x9;socklen_t addrlen;&#xA;&#xA;&#x9;char remoteIP[INET6_ADDRSTRLEN];&#xA;&#xA;&#x9;struct timeval tv;&#xA;&#xA;public:&#xA;&#x9;Socket();&#xA;&#x9;virtual ~Socket();&#xA;&#x9;virtual void configure(std::map&lt;std::string, std::string> configList);&#xA;&#x9;virtual const bool canConnect() const;&#xA;&#x9;virtual int connect();&#xA;&#x9;virtual void disconnect();&#xA;&#x9;virtual std::string read();&#xA;&#x9;virtual void sendData(std::string data);&#xA;&#xA;&#x9;const int getPort() const;&#xA;&#x9;void setPort(const int port);&#xA;&#xA;&#x9;const std::string getAddress() const;&#xA;&#x9;void setAddress(const std::string address);&#xA;};&#xA;&#xA;#endif /* SOCKET_HH_ */" sourceFile="/*&#xA; * Socket.cc&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#include &quot;Socket.hh&quot;&#xA;&#xA;#include &lt;stdio.h>&#xA;#include &lt;stdlib.h>&#xA;#include &lt;string.h>&#xA;#include &lt;unistd.h>&#xA;#include &lt;sys/types.h>&#xA;#include &lt;sys/socket.h>&#xA;#include &lt;netinet/in.h>&#xA;#include &lt;arpa/inet.h>&#xA;#include &lt;netdb.h>&#xA;#include &lt;sstream>&#xA;&#xA;// get sockaddr, IPv4 or IPv6:&#xA;void *get_in_addr(struct sockaddr *sa) {&#xA;&#x9;if (sa->sa_family == AF_INET) {&#xA;&#x9;&#x9;return &amp;(((struct sockaddr_in*) sa)->sin_addr);&#xA;&#x9;}&#xA;&#xA;&#x9;return &amp;(((struct sockaddr_in6*) sa)->sin6_addr);&#xA;}&#xA;&#xA;Socket::Socket() :&#xA;&#x9;&#x9;Method() {&#xA;&#x9;this->setPort(8080);&#xA;&#x9;this->setAddress(&quot;localhost&quot;);&#xA;}&#xA;&#xA;Socket::~Socket() {&#xA;}&#xA;&#xA;void Socket::configure(std::map&lt;std::string, std::string> configList) {&#xA;&#xA;&#x9;std::string port, address;&#xA;&#x9;port = this->getConfig(configList, &quot;port&quot;);&#xA;&#x9;address = this->getConfig(configList, &quot;address&quot;);&#xA;&#xA;&#x9;if (!port.empty())&#xA;&#x9;&#x9;this->setPort(atoi(port.c_str()));&#xA;&#xA;&#x9;if (!address.empty())&#xA;&#x9;&#x9;this->setAddress(address);&#xA;&#xA;&#x9;printf(&quot;address: %s, port: %d\n&quot;, getAddress().c_str(), getPort());&#xA;}&#xA;&#xA;const bool Socket::canConnect() const {&#xA;&#x9;return true;&#xA;}&#xA;&#xA;int Socket::connect() {&#xA;&#xA;&#x9;int rv, result = -1;&#xA;&#x9;struct addrinfo hints, *ai, *p;&#xA;&#x9;int yes = 1;   // for setsockopt&#xA;&#xA;&#x9;std::stringstream port;&#xA;&#x9;port &lt;&lt; this->getPort();&#xA;&#xA;&#x9;tv.tv_sec = 0;&#xA;&#x9;tv.tv_usec = 0;&#xA;&#xA;&#x9;FD_ZERO(&amp;master);    // clear the master and temp sets&#xA;&#x9;FD_ZERO(&amp;read_fds);&#xA;&#xA;&#x9;// get us a socket and bind it&#xA;&#x9;memset(&amp;hints, 0, sizeof hints);&#xA;&#x9;hints.ai_family = AF_UNSPEC;&#xA;&#x9;hints.ai_socktype = SOCK_STREAM;&#xA;&#x9;hints.ai_flags = AI_PASSIVE;&#xA;&#x9;if ((rv = getaddrinfo(NULL, port.str().c_str(), &amp;hints, &amp;ai)) != 0) {&#xA;&#x9;&#x9;fprintf(stderr, &quot;selectserver: %s\n&quot;, gai_strerror(rv));&#xA;&#x9;&#x9;exit(1);&#xA;&#x9;}&#xA;&#xA;&#x9;for (p = ai; p != NULL; p = p->ai_next) {&#xA;&#x9;&#x9;listener = socket(p->ai_family, p->ai_socktype, p->ai_protocol);&#xA;&#x9;&#x9;if (listener &lt; 0) {&#xA;&#x9;&#x9;&#x9;continue;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;// lose the pesky &quot;address already in use&quot; error message&#xA;&#x9;&#x9;setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &amp;yes, sizeof(int));&#xA;&#xA;&#x9;&#x9;if (bind(listener, p->ai_addr, p->ai_addrlen) &lt; 0) {&#xA;&#x9;&#x9;&#x9;close(listener);&#xA;&#x9;&#x9;&#x9;continue;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;break;&#xA;&#x9;}&#xA;&#xA;&#x9;&#x9;// if we got here, it means we didn't get bound&#xA;&#x9;if (p == NULL) {&#xA;&#x9;&#x9;fprintf(stderr, &quot;selectserver: failed to bind\n&quot;);&#xA;&#x9;&#x9;exit(2);&#xA;&#x9;}&#xA;&#xA;&#x9;freeaddrinfo(ai); // all done with this&#xA;&#xA;&#x9;// listen&#xA;&#x9;if (listen(listener, 10) == -1) {&#xA;&#x9;&#x9;perror(&quot;listen&quot;);&#xA;&#x9;&#x9;exit(3);&#xA;&#x9;}&#xA;&#xA;&#x9;// add the listener to the master set&#xA;&#x9;FD_SET(listener, &amp;master);&#xA;&#xA;&#x9;// keep track of the biggest file descriptor&#xA;&#x9;fdmax = listener; // so far, it's this one&#xA;&#xA;&#x9;return result;&#xA;&#xA;}&#xA;&#xA;void Socket::disconnect() {&#xA;}&#xA;&#xA;std::string Socket::read() {&#xA;&#xA;&#x9;// main loop&#xA;&#x9;read_fds = master; // copy it&#xA;&#x9;int rc = select(fdmax + 1, &amp;read_fds, NULL, NULL, &amp;tv);&#xA;&#x9;if (rc == -1) {&#xA;&#x9;&#x9;perror(&quot;select&quot;);&#xA;&#x9;&#x9;exit(4);&#xA;&#x9;}&#xA;&#xA;&#x9;tv.tv_sec = 0;&#xA;&#x9;tv.tv_usec = 0;&#xA;&#xA;&#x9;if (rc == 0) {&#xA;&#x9;&#x9;//   printf(&quot;timeout\n&quot;);&#xA;&#x9;&#x9;return &quot;&quot;;&#xA;&#x9;}&#xA;&#xA;&#x9;int i = 0;&#xA;&#xA;&#x9;// run through the existing connections looking for data to read&#xA;&#x9;for (i = 0; i &lt;= fdmax; i++) {&#xA;&#x9;&#x9;if (FD_ISSET(i, &amp;read_fds)) { // we got one!!&#xA;&#x9;&#x9;&#x9;if (i == listener) {&#xA;&#x9;&#x9;&#x9;&#x9;// handle new connections&#xA;&#x9;&#x9;&#x9;&#x9;addrlen = sizeof remoteaddr;&#xA;&#x9;&#x9;&#x9;&#x9;int newfd = accept(listener, (struct sockaddr *) &amp;remoteaddr,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&amp;addrlen);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;char remoteIP[INET6_ADDRSTRLEN];&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if (newfd == -1) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;perror(&quot;accept&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;FD_SET(newfd, &amp;master); // add to master set&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (newfd > fdmax) {    // keep track of the max&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;fdmax = newfd;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;printf(&quot;new connection from %s on &quot;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&quot;socket %d\n&quot;,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;inet_ntop(remoteaddr.ss_family,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;get_in_addr((struct sockaddr*) &amp;remoteaddr),&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;remoteIP, INET6_ADDRSTRLEN), newfd);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;char buf[256];    // buffer for client data&#xA;&#x9;&#x9;&#x9;&#x9;int nbytes;&#xA;&#x9;&#x9;&#x9;&#x9;// handle data from a client&#xA;&#x9;&#x9;&#x9;&#x9;if ((nbytes = recv(i, buf, sizeof buf, 0)) &lt;= 0) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// got error or connection closed by client&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (nbytes == 0) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// connection closed&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;printf(&quot;socket %d hung up\n&quot;, i);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;perror(&quot;recv&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;close(i); // bye!&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;FD_CLR(i, &amp;master); // remove from master set&#xA;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;std::string str(buf, buf + nbytes - 2);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return str;&#xA;//    printf(&quot;new data: %s\n&quot;, buf);&#xA;//    // we got some data from a client&#xA;//    int j = 0;&#xA;//    for(j = 0; j &lt;= fdmax; j++) {&#xA;//        // send to everyone!&#xA;//        if (FD_ISSET(j, &amp;master)) {&#xA;//            // except the listener and ourselves&#xA;//            if (j != listener &amp;&amp; j != i) {&#xA;//                if (send(j, buf, nbytes, 0) == -1) {&#xA;//                    perror(&quot;send&quot;);&#xA;//                }&#xA;//            }&#xA;//        }&#xA;//    }&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;} // END handle data from client&#xA;&#x9;&#x9;} // END got new incoming connection&#xA;&#x9;} // END looping through file descriptors&#xA;&#x9;return &quot;&quot;;&#xA;}&#xA;&#xA;void Socket::sendData(std::string data) {&#xA;&#x9;int j = 0;&#xA;&#x9;for (j = 0; j &lt;= fdmax; j++) {&#xA;&#x9;&#x9;// send to everyone&#xA;&#x9;&#x9;if (FD_ISSET(j, &amp;master)) {&#xA;&#x9;&#x9;&#x9;// no exception&#xA;&#x9;&#x9;&#x9;if (j != listener) {&#xA;&#x9;&#x9;&#x9;&#x9;if (write(j, data.c_str(), data.length()) == -1) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;//    perror(&quot;does not work\n&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;&#xA;const int Socket::getPort() const {&#xA;&#x9;return this->port;&#xA;}&#xA;&#xA;void Socket::setPort(const int port) {&#xA;&#x9;this->port = port;&#xA;}&#xA;&#xA;const std::string Socket::getAddress() const {&#xA;&#x9;return this->address;&#xA;}&#xA;&#xA;void Socket::setAddress(const std::string address) {&#xA;&#x9;this->address = address;&#xA;}"/>
  <RTCppProperties:ArtifactProperties xmi:id="_fFB6NnovEeesmeF6iS6c6Q" base_Artifact="_fE_eHHovEeesmeF6iS6c6Q" includeFile="/*&#xA; * Config.hh&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#ifndef CONFIG_HH_&#xA;#define CONFIG_HH_&#xA;&#xA;#include &lt;string>&#xA;#include &lt;map>&#xA;&#xA;class Config {&#xA;&#xA;private:&#xA;&#x9;std::string configFileName;&#xA;&#x9;std::string fieldSeparator;&#xA;&#x9;std::string commentStr;&#xA;&#x9;std::string getConfigPath();&#xA;&#x9;std::map&lt;std::string, std::string> configList;&#xA;&#xA;public:&#xA;&#x9;Config();&#xA;&#x9;~Config();&#xA;&#x9;int load();&#xA;&#x9;void append(std::string key, std::string value);&#xA;&#x9;std::string get(std::string key);&#xA;&#x9;void setConfigFileName(const std::string configFileName);&#xA;&#x9;const std::string getConfigFileName() const;&#xA;&#xA;&#x9;void setFieldSeparator(const std::string fieldSeparator);&#xA;&#x9;const std::string getFieldSeparator() const;&#xA;&#xA;&#x9;void setCommentStr(const std::string commentStr);&#xA;&#x9;const std::string getCommentStr() const;&#xA;&#xA;&#x9;const std::map&lt;std::string, std::string> getConfigList() const;&#xA;};&#xA;&#xA;#endif /* CONFIG_HH_ */" sourceFile="/*&#xA; * Config.cc&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#include &quot;Config.hh&quot;&#xA;&#xA;#include &lt;stdio.h>&#xA;#include &lt;fstream>&#xA;#include &lt;iostream>&#xA;#include &lt;unistd.h>&#xA;&#xA;using namespace std;&#xA;&#xA;Config::Config() {&#xA;&#x9;this->setConfigFileName(&quot;config&quot;);&#xA;&#x9;this->setFieldSeparator(&quot;=&quot;);&#xA;&#x9;this->setCommentStr(&quot;#&quot;);&#xA;}&#xA;&#xA;Config::~Config() {&#xA;}&#xA;&#xA;int Config::load() {&#xA;&#xA;&#x9;int result = 0;&#xA;&#x9;std::string prefix = &quot;&quot;;&#xA;&#x9;std::string configPath = this->getConfigPath();&#xA;&#x9;std::ifstream configFile(configPath.c_str());&#xA;&#x9;std::string line;&#xA;&#xA;&#x9;if (configFile.is_open()) {&#xA;&#x9;&#x9;while (std::getline(configFile, line)) {&#xA;&#xA;&#x9;&#x9;&#x9;std::string key, value;&#xA;&#xA;&#x9;&#x9;&#x9;// skip the space and comment line&#xA;&#x9;&#x9;&#x9;std::string::size_type nonSpaceCharIndex = line.find_first_not_of(&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&quot; \f\t\v&quot;);&#xA;&#x9;&#x9;&#x9;if (nonSpaceCharIndex == std::string::npos)&#xA;&#x9;&#x9;&#x9;&#x9;continue; // line is empty, skp it&#xA;&#xA;&#x9;&#x9;&#x9;if (this->commentStr.find(line[nonSpaceCharIndex])&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;!= std::string::npos)&#xA;&#x9;&#x9;&#x9;&#x9;continue; // skip the line , it is a comment line&#xA;&#xA;&#x9;&#x9;&#x9;// Check if it is a definition of a specific rule&#xA;&#x9;&#x9;&#x9;std::string::size_type prefixIndex = line.find(&quot;[&quot;,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;nonSpaceCharIndex);&#xA;&#x9;&#x9;&#x9;if (prefixIndex != std::string::npos) {&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;std::string::size_type valueNonSpaceCharIndex =&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;line.find_first_not_of(&quot; \f\t\v&quot;, prefixIndex + 1);&#xA;&#x9;&#x9;&#x9;&#x9;std::string p = line.substr(valueNonSpaceCharIndex);&#xA;&#x9;&#x9;&#x9;&#x9;p.erase(p.find_last_not_of(&quot; \f\t\v&quot;));&#xA;&#x9;&#x9;&#x9;&#x9;p.erase(p.find_last_not_of(&quot; \f\t\v&quot;) + 1);&#xA;&#x9;&#x9;&#x9;&#x9;prefix = p;&#xA;&#x9;&#x9;&#x9;&#x9;continue;&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;// extract key value&#xA;&#x9;&#x9;&#x9;std::string::size_type sepIndex = line.find(&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;this->getFieldSeparator(), nonSpaceCharIndex);&#xA;&#x9;&#x9;&#x9;if (sepIndex == std::string::npos)&#xA;&#x9;&#x9;&#x9;&#x9;continue; // the line doesn't contain the seperator&#xA;&#xA;&#x9;&#x9;&#x9;key = line.substr(nonSpaceCharIndex, sepIndex - nonSpaceCharIndex);&#xA;&#x9;&#x9;&#x9;key.erase(key.find_last_not_of(&quot; \f\t\v&quot;) + 1);&#xA;&#xA;&#x9;&#x9;&#x9;if (key.empty())&#xA;&#x9;&#x9;&#x9;&#x9;continue; // the kwy should have value&#xA;&#xA;&#x9;&#x9;&#x9;if (sepIndex + 1 == line.length())&#xA;&#x9;&#x9;&#x9;&#x9;continue; // there is no value&#xA;&#xA;/// extract the value&#xA;&#x9;&#x9;&#x9;std::string::size_type valueNonSpaceCharIndex =&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;line.find_first_not_of(&quot; \f\t\v&quot;, sepIndex + 1);&#xA;&#xA;&#x9;&#x9;&#x9;if (valueNonSpaceCharIndex == std::string::npos)&#xA;&#x9;&#x9;&#x9;&#x9;continue; // there is no value&#xA;&#xA;&#x9;&#x9;&#x9;std::string::size_type valueLastNonSpaceCharIndex =&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;line.find_last_not_of(&quot; \f\t\v&quot;);&#xA;&#x9;&#x9;&#x9;value = line.substr(valueNonSpaceCharIndex,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;valueLastNonSpaceCharIndex - valueNonSpaceCharIndex + 1);&#xA;&#x9;&#x9;&#x9;if (!prefix.empty())&#xA;&#x9;&#x9;&#x9;&#x9;key = prefix + &quot;.&quot; + key;&#xA;&#x9;&#x9;&#x9;this->append(key, value);&#xA;&#x9;&#x9;&#x9;printf(&quot;%s=%s\n&quot;, key.c_str(), value.c_str());&#xA;&#x9;&#x9;&#x9;result = result + 1;&#xA;&#x9;&#x9;}&#xA;&#x9;} else {&#xA;&#x9;&#x9;std::cerr &lt;&lt; &quot;Error in reading configuration file from &quot; &lt;&lt; configPath&#xA;&#x9;&#x9;&#x9;&#x9;&lt;&lt; std::endl;&#xA;&#x9;&#x9;result = -1;&#xA;&#x9;}&#xA;&#x9;configFile.close();&#xA;&#x9;return result;&#xA;}&#xA;&#xA;void Config::append(std::string key, std::string value) {&#xA;&#x9;if (!key.empty())&#xA;&#x9;&#x9;this->configList[key] = value;&#xA;}&#xA;&#xA;std::string Config::get(std::string key) {&#xA;&#x9;bool n = this->configList.count(key);&#xA;&#x9;return (n) ? this->configList.at(key) : &quot;&quot;;&#xA;}&#xA;&#xA;/**&#xA; * Resolve the full path from the exec path&#xA; */&#xA;std::string Config::getConfigPath() {&#xA;&#xA;&#x9;char result[255];&#xA;&#x9;std::string path;&#xA;&#xA;&#x9;ssize_t len = ::readlink(&quot;/proc/self/exe&quot;, result, sizeof(result));&#xA;&#x9;if (len != -1) {&#xA;&#x9;&#x9;path = std::string(result);&#xA;&#x9;}&#xA;&#xA;// find the last &quot;/&quot; position&#xA;&#x9;size_t n = path.rfind('/');&#xA;&#xA;// remove the last fragment of the path&#xA;&#x9;path = (n > 0) ? path.substr(0, n) : &quot;&quot;;&#xA;&#xA;// return the full path&#xA;&#x9;return (path != &quot;&quot;) ?&#xA;&#x9;&#x9;&#x9;path + &quot;/&quot; + this->configFileName : this->configFileName;&#xA;}&#xA;&#xA;void Config::setConfigFileName(const std::string configFileName) {&#xA;&#x9;this->configFileName = configFileName;&#xA;}&#xA;&#xA;const std::string Config::getConfigFileName() const {&#xA;&#x9;return this->configFileName;&#xA;}&#xA;&#xA;void Config::setFieldSeparator(const std::string fieldSeparator) {&#xA;&#x9;this->fieldSeparator = fieldSeparator;&#xA;}&#xA;&#xA;const std::string Config::getFieldSeparator() const {&#xA;&#x9;return this->fieldSeparator;&#xA;}&#xA;&#xA;void Config::setCommentStr(const std::string commentStr) {&#xA;&#x9;this->commentStr = commentStr;&#xA;}&#xA;&#xA;const std::string Config::getCommentStr() const {&#xA;&#x9;return this->commentStr;&#xA;}&#xA;&#xA;const std::map&lt;std::string, std::string> Config::getConfigList() const {&#xA;&#x9;return this->configList;&#xA;}"/>
  <UMLRealTime:RTPort xmi:id="_hqIUMHovEeesmeF6iS6c6Q" isPublish="false" isWired="false" base_Port="_hqCNkHovEeesmeF6iS6c6Q"/>
  <UMLRealTime:CapsulePart xmi:id="_nnPL0HovEeesmeF6iS6c6Q" base_Property="_nnMvkHovEeesmeF6iS6c6Q"/>
  <RTCppProperties:PassiveClassProperties xmi:id="_n7ytQHo0EeesmeF6iS6c6Q" headerPreface="#include &lt;iostream>&#xA;&#xA;using namespace std;&#xA;" implementationPreface="" base_Class="_VDAPMHFpEeepH5jGTij4Cg" publicDeclarations="friend ostream &amp; operator&lt;&lt;( ostream &amp; os, const Zombie &amp; z)&#xA;{&#xA;    os &lt;&lt; &quot;Zombie(\&quot;&quot; &lt;&lt; z.x &lt;&lt; z.y &lt;&lt; z.d &lt;&lt; &quot;\&quot;)&quot;;&#xA;    return os;&#xA;}&#xA;"/>
  <RTCppProperties:CapsuleProperties xmi:id="_d-bvEHxfEeeS-rP0X-36Iw" implementationPreface="#include &lt;iostream>" base_Class="_FQa0MHL-EeeXs9sY7gI7cA"/>
</xmi:XMI>
