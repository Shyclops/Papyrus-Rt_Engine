<?xml version="1.0" encoding="UTF-8"?>
<xmi:XMI xmi:version="20131001" xmlns:xmi="http://www.omg.org/spec/XMI/20131001" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:ActionLanguage="http://www.omg.org/spec/ALF/20120827/ActionLanguage-Profile" xmlns:RTCppProperties="http://www.eclipse.org/papyrus/umlrt/cppproperties" xmlns:UMLRTStateMachines="http://www.eclipse.org/papyrus/umlrt/statemachine" xmlns:UMLRealTime="http://www.eclipse.org/papyrus/umlrt" xmlns:ecore="http://www.eclipse.org/emf/2002/Ecore" xmlns:uml="http://www.eclipse.org/uml2/5.0.0/UML" xsi:schemaLocation="http://www.omg.org/spec/ALF/20120827/ActionLanguage-Profile pathmap://PAPYRUS_ACTIONLANGUAGE_PROFILE/ActionLanguage-Profile.profile.uml#_Kv8EIKFXEeS_KNX0nfvIVQ">
  <uml:Model xmi:id="_g0QecDbLEeeS0ZUearuafA" name="Engine">
    <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_g0QecTbLEeeS0ZUearuafA" source="http://www.eclipse.org/papyrus-rt/language/1.0.0">
      <details xmi:type="ecore:EStringToStringMapEntry" xmi:id="_g0QecjbLEeeS0ZUearuafA" key="language" value="umlrt-cpp"/>
    </eAnnotations>
    <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_TRuPYDphEeeXjLrCUGhTRw" source="UMLRT_Default_top">
      <details xmi:type="ecore:EStringToStringMapEntry" xmi:id="_TRx5wDphEeeXjLrCUGhTRw" key="top_name" value="Top"/>
    </eAnnotations>
    <packagedElement xmi:type="uml:Package" xmi:id="_EpgTwDmbEeetSfDhTP5ZLQ" name="Directions">
      <packagedElement xmi:type="uml:Collaboration" xmi:id="_EpeekDmbEeetSfDhTP5ZLQ" name="Directions">
        <interfaceRealization xmi:type="uml:InterfaceRealization" xmi:id="_EpiwATmbEeetSfDhTP5ZLQ" client="_EpeekDmbEeetSfDhTP5ZLQ" supplier="_Ephh4DmbEeetSfDhTP5ZLQ" contract="_Ephh4DmbEeetSfDhTP5ZLQ"/>
        <interfaceRealization xmi:type="uml:InterfaceRealization" xmi:id="_EpmaYDmbEeetSfDhTP5ZLQ" client="_EpeekDmbEeetSfDhTP5ZLQ" supplier="_EplMQDmbEeetSfDhTP5ZLQ" contract="_EplMQDmbEeetSfDhTP5ZLQ"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Interface" xmi:id="_Ephh4DmbEeetSfDhTP5ZLQ" name="Directions">
        <ownedOperation xmi:type="uml:Operation" xmi:id="_c25r4DmbEeetSfDhTP5ZLQ" name="directionsCalc">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_BxtKwDmcEeetSfDhTP5ZLQ" name="X">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_Bxw1IDmcEeetSfDhTP5ZLQ" name="Y">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_Ok3sgDwTEeez78_2BqgPcw" name="Direction">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="_KBqR8DwREeez78_2BqgPcw" name="directions">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_kUjW8DwREeez78_2BqgPcw" name="Direction">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="_VNDTgDvpEeePyrL5fVHxNw" name="exits"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Interface" xmi:id="_EpjXEDmbEeetSfDhTP5ZLQ" name="Directions~">
        <ownedOperation xmi:type="uml:Operation" xmi:id="_PyhPkDmbEeetSfDhTP5ZLQ" name="directionCalc">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_88fIQDmbEeetSfDhTP5ZLQ" name="X">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_-UbLkDmbEeetSfDhTP5ZLQ" name="Y">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="_IytLgDwREeez78_2BqgPcw" name="direction">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_kK9WEDwREeez78_2BqgPcw" name="Direction">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="_XB7KcDvpEeePyrL5fVHxNw" name="exit"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Usage" xmi:id="_EpklMDmbEeetSfDhTP5ZLQ" client="_EpeekDmbEeetSfDhTP5ZLQ" supplier="_EpjXEDmbEeetSfDhTP5ZLQ"/>
      <packagedElement xmi:type="uml:AnyReceiveEvent" xmi:id="_EpklMTmbEeetSfDhTP5ZLQ" name="*"/>
      <packagedElement xmi:type="uml:Interface" xmi:id="_EplMQDmbEeetSfDhTP5ZLQ" name="DirectionsIO"/>
      <packagedElement xmi:type="uml:Usage" xmi:id="_EpmaYTmbEeetSfDhTP5ZLQ" client="_EpeekDmbEeetSfDhTP5ZLQ" supplier="_EplMQDmbEeetSfDhTP5ZLQ"/>
      <packagedElement xmi:type="uml:CallEvent" xmi:id="_Pyh2oDmbEeetSfDhTP5ZLQ" operation="_PyhPkDmbEeetSfDhTP5ZLQ"/>
      <packagedElement xmi:type="uml:CallEvent" xmi:id="_c26S8DmbEeetSfDhTP5ZLQ" operation="_c25r4DmbEeetSfDhTP5ZLQ"/>
      <packagedElement xmi:type="uml:CallEvent" xmi:id="_VNEhoDvpEeePyrL5fVHxNw" operation="_VNDTgDvpEeePyrL5fVHxNw"/>
      <packagedElement xmi:type="uml:CallEvent" xmi:id="_XB7xgDvpEeePyrL5fVHxNw" operation="_XB7KcDvpEeePyrL5fVHxNw"/>
      <packagedElement xmi:type="uml:CallEvent" xmi:id="_IyvnwDwREeez78_2BqgPcw" operation="_IytLgDwREeez78_2BqgPcw"/>
      <packagedElement xmi:type="uml:CallEvent" xmi:id="_KBsHIDwREeez78_2BqgPcw" operation="_KBqR8DwREeez78_2BqgPcw"/>
    </packagedElement>
    <packagedElement xmi:type="uml:Package" xmi:id="_NBRMkDvjEeePyrL5fVHxNw" name="Test">
      <packagedElement xmi:type="uml:Collaboration" xmi:id="_NBM7IDvjEeePyrL5fVHxNw" name="Test">
        <interfaceRealization xmi:type="uml:InterfaceRealization" xmi:id="_NBeA4DvjEeePyrL5fVHxNw" client="_NBM7IDvjEeePyrL5fVHxNw" supplier="_NBZIYDvjEeePyrL5fVHxNw" contract="_NBZIYDvjEeePyrL5fVHxNw"/>
        <interfaceRealization xmi:type="uml:InterfaceRealization" xmi:id="_NBnx4DvjEeePyrL5fVHxNw" client="_NBM7IDvjEeePyrL5fVHxNw" supplier="_NBkHgDvjEeePyrL5fVHxNw" contract="_NBkHgDvjEeePyrL5fVHxNw"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Interface" xmi:id="_NBZIYDvjEeePyrL5fVHxNw" name="Test">
        <ownedOperation xmi:type="uml:Operation" xmi:id="_Wp5TsDvjEeePyrL5fVHxNw" name="isStartIn">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_nrDHkDvjEeePyrL5fVHxNw" name="X">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_VJKsgGfwEee-Kre0NmQF5w" name="Y">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="_QT6MkDvkEeePyrL5fVHxNw" name="isReadyIn">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_rLS6MDvuEeePyrL5fVHxNw" name="X">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_rcJZoDvuEeePyrL5fVHxNw" name="Y">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
        </ownedOperation>
      </packagedElement>
      <packagedElement xmi:type="uml:Interface" xmi:id="_NBf2EDvjEeePyrL5fVHxNw" name="Test~">
        <ownedOperation xmi:type="uml:Operation" xmi:id="_UHUpQDvjEeePyrL5fVHxNw" name="isStartOut">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_fSRqgGfwEee-Kre0NmQF5w" name="X">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_g1hl8GfwEee-Kre0NmQF5w" name="Y">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="_O4c7MDvkEeePyrL5fVHxNw" name="isReadyOut">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_aW3bEDvrEeePyrL5fVHxNw" name="X">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_cXLtADvrEeePyrL5fVHxNw" name="Y">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
        </ownedOperation>
      </packagedElement>
      <packagedElement xmi:type="uml:Usage" xmi:id="_NBiSUDvjEeePyrL5fVHxNw" client="_NBM7IDvjEeePyrL5fVHxNw" supplier="_NBf2EDvjEeePyrL5fVHxNw"/>
      <packagedElement xmi:type="uml:AnyReceiveEvent" xmi:id="_NBiSUTvjEeePyrL5fVHxNw" name="*"/>
      <packagedElement xmi:type="uml:Interface" xmi:id="_NBkHgDvjEeePyrL5fVHxNw" name="TestIO"/>
      <packagedElement xmi:type="uml:Usage" xmi:id="_NBoY8DvjEeePyrL5fVHxNw" client="_NBM7IDvjEeePyrL5fVHxNw" supplier="_NBkHgDvjEeePyrL5fVHxNw"/>
      <packagedElement xmi:type="uml:CallEvent" xmi:id="_UHWecDvjEeePyrL5fVHxNw" operation="_UHUpQDvjEeePyrL5fVHxNw"/>
      <packagedElement xmi:type="uml:CallEvent" xmi:id="_Wp6h0DvjEeePyrL5fVHxNw" operation="_Wp5TsDvjEeePyrL5fVHxNw"/>
      <packagedElement xmi:type="uml:CallEvent" xmi:id="_O4eJUDvkEeePyrL5fVHxNw" operation="_O4c7MDvkEeePyrL5fVHxNw"/>
      <packagedElement xmi:type="uml:CallEvent" xmi:id="_QT6zoDvkEeePyrL5fVHxNw" operation="_QT6MkDvkEeePyrL5fVHxNw"/>
    </packagedElement>
    <packagedElement xmi:type="uml:Class" xmi:id="_B6RyMDbOEeeS0ZUearuafA" name="Top" isActive="true">
      <ownedAttribute xmi:type="uml:Property" xmi:id="_SQAVkDliEeeHA4oSpVV8Ow" name="test" visibility="protected" type="_9yzxEDbOEeeS0ZUearuafA" isOrdered="true" aggregation="composite"/>
      <ownedAttribute xmi:type="uml:Property" xmi:id="___ZaUDs1Eee4vrzjGIvOwQ" name="testCont" visibility="protected" type="__7sO4DmcEeetSfDhTP5ZLQ" isOrdered="true" aggregation="composite"/>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_hV01cDvkEeePyrL5fVHxNw" name="calculation" visibility="protected" type="_LFgVYDvhEeePyrL5fVHxNw" isOrdered="true" aggregation="composite"/>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_0JZCIDvkEeePyrL5fVHxNw" name="detection" visibility="protected" type="_JK_5IDs0Eee4vrzjGIvOwQ" isOrdered="true" aggregation="composite"/>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_-GxfsG4VEeeUNoAgRbC5hw" name="observer" visibility="protected" type="_qQdcnm4VEeeUNoAgRbC5hw" isOrdered="true" aggregation="composite"/>
      <ownedConnector xmi:type="uml:Connector" xmi:id="_vFI2kDwPEeez78_2BqgPcw" name="RTConnector7">
        <end xmi:type="uml:ConnectorEnd" xmi:id="_vFLS0DwPEeez78_2BqgPcw" partWithPort="___ZaUDs1Eee4vrzjGIvOwQ" role="_qi3lQDwPEeez78_2BqgPcw"/>
        <end xmi:type="uml:ConnectorEnd" xmi:id="_vFMg8DwPEeez78_2BqgPcw" partWithPort="_hV01cDvkEeePyrL5fVHxNw" role="_s71WoDvhEeePyrL5fVHxNw"/>
      </ownedConnector>
      <ownedConnector xmi:type="uml:Connector" xmi:id="_oJDrwEAhEeecSdgC5rjddw" name="RTConnector8">
        <end xmi:type="uml:ConnectorEnd" xmi:id="_oJOq4EAhEeecSdgC5rjddw" partWithPort="_0JZCIDvkEeePyrL5fVHxNw" role="_HBMhgDvYEeeVBItGYDMaLQ"/>
        <end xmi:type="uml:ConnectorEnd" xmi:id="_oJP5AEAhEeecSdgC5rjddw" partWithPort="___ZaUDs1Eee4vrzjGIvOwQ" role="_BJxSwDvmEeePyrL5fVHxNw"/>
      </ownedConnector>
      <ownedConnector xmi:type="uml:Connector" xmi:id="_Od3XYETsEeem9u7KRr3TyA" name="RTConnector9">
        <end xmi:type="uml:ConnectorEnd" xmi:id="_Or-E0ETsEeem9u7KRr3TyA" partWithPort="_SQAVkDliEeeHA4oSpVV8Ow" role="_wEmS4ETrEeem9u7KRr3TyA"/>
        <end xmi:type="uml:ConnectorEnd" xmi:id="_Or-E0UTsEeem9u7KRr3TyA" partWithPort="_hV01cDvkEeePyrL5fVHxNw" role="_s58_8DvkEeePyrL5fVHxNw"/>
      </ownedConnector>
    </packagedElement>
    <packagedElement xmi:type="uml:Class" xmi:id="_9yzxEDbOEeeS0ZUearuafA" name="PreExecute" classifierBehavior="_cOGO0DbPEeeS0ZUearuafA" isActive="true">
      <ownedAttribute xmi:type="uml:Port" xmi:id="_XtyFUDbPEeeS0ZUearuafA" name="log" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
        <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6kIb0IeXEeSVyrlWP4nYew"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_lIhCgDeHEee0Cb7xo9L6qw" name="test" visibility="public" type="_NBM7IDvjEeePyrL5fVHxNw" isOrdered="true" aggregation="composite" isBehavior="true" isConjugated="true">
        <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_RVEasDv8EeePyrL5fVHxNw" value="2"/>
        <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_RVRPADv8EeePyrL5fVHxNw" value="2"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_UouR8EAcEeecSdgC5rjddw" name="directions" visibility="protected" type="_EpeekDmbEeetSfDhTP5ZLQ" isOrdered="true" aggregation="composite" isBehavior="true" isConjugated="true" isService="false"/>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_wEmS4ETrEeem9u7KRr3TyA" name="test2" visibility="public" type="_NBM7IDvjEeePyrL5fVHxNw" isOrdered="true" aggregation="composite" isBehavior="true" isConjugated="true"/>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_tj7YcG4VEeeUNoAgRbC5hw" name="observation" visibility="protected" type="_qQdckm4VEeeUNoAgRbC5hw" isOrdered="true" aggregation="composite" isBehavior="true" isService="false"/>
      <ownedBehavior xmi:type="uml:StateMachine" xmi:id="_cOGO0DbPEeeS0ZUearuafA" name="Premake" isAbstract="true" isReentrant="false">
        <region xmi:type="uml:Region" xmi:id="_cO45ADbPEeeS0ZUearuafA" name="Region">
          <transition xmi:type="uml:Transition" xmi:id="_cPiZQDbPEeeS0ZUearuafA" name="Initial" source="_cPCC8DbPEeeS0ZUearuafA" target="_cPUW0DbPEeeS0ZUearuafA">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_1E_XMDeQEee0Cb7xo9L6qw" name="Effect" isReentrant="false">
              <language>C++</language>
              <body>test2.isStartIn(0,0).send();</body>
            </effect>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_cVZCsEAcEeecSdgC5rjddw" name="" source="_Kep4UDmSEeetSfDhTP5ZLQ" target="_ZzlNQEAcEeecSdgC5rjddw">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_cmESQEn8EeedZqJ4_o8GcQ" name="Effect" isReentrant="false">
              <language>C++</language>
              <body></body>
            </effect>
            <trigger xmi:type="uml:Trigger" xmi:id="_nKaPAEAdEeecSdgC5rjddw" event="_XB7xgDvpEeePyrL5fVHxNw" port="_UouR8EAcEeecSdgC5rjddw"/>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_RIBjkGf2Eee-Kre0NmQF5w" name="" kind="external" source="_cPUW0DbPEeeS0ZUearuafA" target="_Kep4UDmSEeetSfDhTP5ZLQ">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_ZXZYwGf2Eee-Kre0NmQF5w" name="Effect" isReentrant="false">
              <language>C++</language>
              <body>log.log(&quot;Pre-execution done&quot;);&#xD;
test.isReadyIn(X,Y).send();</body>
            </effect>
            <trigger xmi:type="uml:Trigger" xmi:id="_ReF6MGf2Eee-Kre0NmQF5w" event="_UHWecDvjEeePyrL5fVHxNw" port="_wEmS4ETrEeem9u7KRr3TyA"/>
          </transition>
          <subvertex xmi:type="uml:Pseudostate" xmi:id="_cPCC8DbPEeeS0ZUearuafA" name=""/>
          <subvertex xmi:type="uml:State" xmi:id="_cPUW0DbPEeeS0ZUearuafA" name="Waiting">
            <ownedComment xmi:type="uml:Comment" xmi:id="_y-eQ0Et_EeeD4eyKVO2S_Q">
              <body>   ~~</body>
            </ownedComment>
            <entry xmi:type="uml:OpaqueBehavior" xmi:id="_tKzd8DeHEee0Cb7xo9L6qw" name="Entry" isReentrant="false">
              <language>C++</language>
              <body></body>
            </entry>
            <exit xmi:type="uml:OpaqueBehavior" xmi:id="__4M6cEoNEeedZqJ4_o8GcQ" name="Exit" isReentrant="false">
              <language>C++</language>
              <body></body>
            </exit>
          </subvertex>
          <subvertex xmi:type="uml:State" xmi:id="_Kep4UDmSEeetSfDhTP5ZLQ" name="Found">
            <entry xmi:type="uml:OpaqueBehavior" xmi:id="_P-T6wDmZEeetSfDhTP5ZLQ" name="Entry" isReentrant="false">
              <language>C++</language>
              <body></body>
            </entry>
          </subvertex>
          <subvertex xmi:type="uml:State" xmi:id="_ZzlNQEAcEeecSdgC5rjddw" name="Exited">
            <entry xmi:type="uml:OpaqueBehavior" xmi:id="_nZVnkEn8EeedZqJ4_o8GcQ" name="Entry" isReentrant="false">
              <language>C++</language>
              <body></body>
            </entry>
          </subvertex>
        </region>
      </ownedBehavior>
    </packagedElement>
    <packagedElement xmi:type="uml:Class" xmi:id="__7sO4DmcEeetSfDhTP5ZLQ" name="TestCont" classifierBehavior="_HTMHMDppEeehJIRyir005Q" isActive="true">
      <ownedAttribute xmi:type="uml:Port" xmi:id="_BJxSwDvmEeePyrL5fVHxNw" name="directions" visibility="public" type="_EpeekDmbEeetSfDhTP5ZLQ" isOrdered="true" aggregation="composite" isBehavior="true"/>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_MRDJMDvmEeePyrL5fVHxNw" name="log" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
        <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6kIb0IeXEeSVyrlWP4nYew"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_ozUTADvqEeePyrL5fVHxNw" name="x" visibility="private">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_ozUTATvqEeePyrL5fVHxNw" value="0"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_pF7F8DvqEeePyrL5fVHxNw" name="y" visibility="private">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_pF7F8TvqEeePyrL5fVHxNw" value="0"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_17g4UDvqEeePyrL5fVHxNw" name="test" visibility="protected" type="_NBM7IDvjEeePyrL5fVHxNw" isOrdered="true" aggregation="composite" isBehavior="true" isService="false"/>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_qi3lQDwPEeez78_2BqgPcw" name="directions2" visibility="public" type="_EpeekDmbEeetSfDhTP5ZLQ" isOrdered="true" aggregation="composite" isBehavior="true" isConjugated="true"/>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_144V8EAaEeecSdgC5rjddw" name="directions3" visibility="public" type="_EpeekDmbEeetSfDhTP5ZLQ" isOrdered="true" aggregation="composite" isBehavior="true">
        <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_fkrzwEAdEeecSdgC5rjddw" value="2"/>
        <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_fl8YAEAdEeecSdgC5rjddw" value="2"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_zHyCkG4VEeeUNoAgRbC5hw" name="observation" visibility="protected" type="_qQdckm4VEeeUNoAgRbC5hw" isOrdered="true" aggregation="composite" isBehavior="true" isService="false"/>
      <ownedBehavior xmi:type="uml:StateMachine" xmi:id="_HTMHMDppEeehJIRyir005Q" name="TestContStateMachine" isReentrant="false">
        <region xmi:type="uml:Region" xmi:id="_HTUDADppEeehJIRyir005Q" name="Region">
          <transition xmi:type="uml:Transition" xmi:id="_HTd0ADppEeehJIRyir005Q" name="Initial" source="_HTXtYDppEeehJIRyir005Q" target="_HTb-0DppEeehJIRyir005Q">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_eK0CIETQEeem9u7KRr3TyA" name="Effect" isReentrant="false">
              <language>C++</language>
              <body></body>
            </effect>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_TWvf4DvuEeePyrL5fVHxNw" name="" source="_evMisDvqEeePyrL5fVHxNw" target="_5YWi4GftEee-Kre0NmQF5w">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_GQdwsDvvEeePyrL5fVHxNw" name="Effect" isReentrant="false">
              <language>C++</language>
              <body>directions2.directionsCalc(x,y,Direction).send();</body>
            </effect>
            <trigger xmi:type="uml:Trigger" xmi:id="_M_IIoDwREeez78_2BqgPcw" event="_KBsHIDwREeez78_2BqgPcw" port="_BJxSwDvmEeePyrL5fVHxNw"/>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_Y7u9ADvvEeePyrL5fVHxNw" name="" source="_evMisDvqEeePyrL5fVHxNw" target="_T7QswDvvEeePyrL5fVHxNw">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_NuN98EAcEeecSdgC5rjddw" name="Effect" isReentrant="false">
              <language>C++</language>
              <body>directions3.exit().send();</body>
            </effect>
            <trigger xmi:type="uml:Trigger" xmi:id="_CHo1AEAfEeecSdgC5rjddw" event="_VNEhoDvpEeePyrL5fVHxNw" port="_BJxSwDvmEeePyrL5fVHxNw"/>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_xS6FwGftEee-Kre0NmQF5w" name="" kind="external" source="_HTb-0DppEeehJIRyir005Q" target="_evMisDvqEeePyrL5fVHxNw">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_2_qNMGftEee-Kre0NmQF5w" name="Effect" isReentrant="false">
              <language>C++</language>
              <body>x = X;&#xD;
y = Y;

Event e1;
    e1.setSourceName(this->getName());
    e1.setParam(&quot;cmd&quot;, &quot;update&quot;);
    observation.event(e1).send();</body>
            </effect>
            <trigger xmi:type="uml:Trigger" xmi:id="_0ob3IGftEee-Kre0NmQF5w" event="_QT6zoDvkEeePyrL5fVHxNw" port="_17g4UDvqEeePyrL5fVHxNw"/>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_Ojfq8GfuEee-Kre0NmQF5w" name="" kind="external" source="_5YWi4GftEee-Kre0NmQF5w" target="_evMisDvqEeePyrL5fVHxNw">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_CAlukGfvEee-Kre0NmQF5w" name="Effect" isReentrant="false">
              <language>C++</language>
              <body>x = X;
y = Y;

</body>
            </effect>
            <trigger xmi:type="uml:Trigger" xmi:id="_OuDpQGf7Eee-Kre0NmQF5w" event="_Pyh2oDmbEeetSfDhTP5ZLQ" port="_qi3lQDwPEeez78_2BqgPcw"/>
          </transition>
          <subvertex xmi:type="uml:Pseudostate" xmi:id="_HTXtYDppEeehJIRyir005Q" name=""/>
          <subvertex xmi:type="uml:State" xmi:id="_HTb-0DppEeehJIRyir005Q" name="Waiting">
            <entry xmi:type="uml:OpaqueBehavior" xmi:id="_ggA-8ETQEeem9u7KRr3TyA" name="Entry" isReentrant="false">
              <language>C++</language>
              <body></body>
            </entry>
          </subvertex>
          <subvertex xmi:type="uml:State" xmi:id="_evMisDvqEeePyrL5fVHxNw" name="Playing">
            <entry xmi:type="uml:OpaqueBehavior" xmi:id="_OiIE4DvvEeePyrL5fVHxNw" name="Entry" isReentrant="false">
              <language>C++</language>
              <body>&#xD;
log.log(&quot;X: %d, Y: %d&quot;, x, y);</body>
            </entry>
          </subvertex>
          <subvertex xmi:type="uml:State" xmi:id="_T7QswDvvEeePyrL5fVHxNw" name="Finished">
            <entry xmi:type="uml:OpaqueBehavior" xmi:id="_rA9dADvvEeePyrL5fVHxNw" name="Entry" isReentrant="false">
              <language>C++</language>
              <body>log.log(&quot;Game Exited&quot;);
</body>
            </entry>
          </subvertex>
          <subvertex xmi:type="uml:State" xmi:id="_5YWi4GftEee-Kre0NmQF5w" name="checkingDirection"/>
        </region>
      </ownedBehavior>
    </packagedElement>
    <packagedElement xmi:type="uml:Class" xmi:id="_JK_5IDs0Eee4vrzjGIvOwQ" name="Detection" classifierBehavior="_Q9xfYDvYEeeVBItGYDMaLQ" isActive="true">
      <ownedAttribute xmi:type="uml:Port" xmi:id="_HBMhgDvYEeeVBItGYDMaLQ" name="directions" visibility="public" type="_EpeekDmbEeetSfDhTP5ZLQ" isOrdered="true" aggregation="composite" isBehavior="true" isConjugated="true"/>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_JOth8DvYEeeVBItGYDMaLQ" name="log" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
        <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6kIb0IeXEeSVyrlWP4nYew"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_raos0DvlEeePyrL5fVHxNw" name="test" visibility="protected" type="_NBM7IDvjEeePyrL5fVHxNw" isOrdered="true" aggregation="composite" isBehavior="true" isService="false"/>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_6dr5kDzHEeeY-4ihoO8v0Q" name="ESC_KEY" visibility="private">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_YokuYDzJEeeY-4ihoO8v0Q" value="27"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_Oo8q8ECXEeeKEZi9P2TNWQ" name="timing" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
        <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_gRZO0EGIEeej7Pd2CJeVfw" name="delay" visibility="private">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_skR8wEGIEeej7Pd2CJeVfw" value="1"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_UKabEGXIEeeOL4Q9GCeqlQ" name="flag">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Boolean"/>
        <defaultValue xmi:type="uml:LiteralBoolean" xmi:id="_X8flkGXIEeeOL4Q9GCeqlQ" value="true"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_z_BMkG4VEeeUNoAgRbC5hw" name="observation" visibility="protected" type="_qQdckm4VEeeUNoAgRbC5hw" isOrdered="true" aggregation="composite" isBehavior="true" isService="false"/>
      <ownedBehavior xmi:type="uml:StateMachine" xmi:id="_Q9xfYDvYEeeVBItGYDMaLQ" name="DetectionStateMachine" isReentrant="false">
        <region xmi:type="uml:Region" xmi:id="_Q96pUDvYEeeVBItGYDMaLQ" name="Region">
          <transition xmi:type="uml:Transition" xmi:id="_Q-G2kDvYEeeVBItGYDMaLQ" name="Initial" source="_Q9-TsDvYEeeVBItGYDMaLQ" target="_sSwBYECXEeeKEZi9P2TNWQ">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_2NdMkEF_Eeej7Pd2CJeVfw" name="Effect" isReentrant="false">
              <language>C++</language>
              <body></body>
            </effect>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_PFwLcECGEeeKEZi9P2TNWQ" name="" guard="_bMUXkGXIEeeOL4Q9GCeqlQ" source="_Q-DzQDvYEeeVBItGYDMaLQ" target="_Q-DzQDvYEeeVBItGYDMaLQ">
            <ownedRule xmi:type="uml:Constraint" xmi:id="_bMUXkGXIEeeOL4Q9GCeqlQ">
              <specification xmi:type="uml:OpaqueExpression" xmi:id="_bMU-oGXIEeeOL4Q9GCeqlQ">
                <language>C++</language>
                <body>return flag;</body>
              </specification>
            </ownedRule>
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_dv4kkEn9EeedZqJ4_o8GcQ" name="Effect" isReentrant="false">
              <language>C++</language>
              <body></body>
            </effect>
            <trigger xmi:type="uml:Trigger" xmi:id="_P7OLIECXEeeKEZi9P2TNWQ" port="_Oo8q8ECXEeeKEZi9P2TNWQ">
              <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
            </trigger>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_9Q7ZwECXEeeKEZi9P2TNWQ" name="" source="_sSwBYECXEeeKEZi9P2TNWQ" target="_Q-DzQDvYEeeVBItGYDMaLQ">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_UptqQEn9EeedZqJ4_o8GcQ" name="Effect" isReentrant="false">
              <language>C++</language>
              <body></body>
            </effect>
            <trigger xmi:type="uml:Trigger" xmi:id="_bmj7cECYEeeKEZi9P2TNWQ" event="_QT6zoDvkEeePyrL5fVHxNw" port="_raos0DvlEeePyrL5fVHxNw"/>
          </transition>
          <subvertex xmi:type="uml:Pseudostate" xmi:id="_Q9-TsDvYEeeVBItGYDMaLQ" name=""/>
          <subvertex xmi:type="uml:State" xmi:id="_Q-DzQDvYEeeVBItGYDMaLQ" name="Playing">
            <entry xmi:type="uml:OpaqueBehavior" xmi:id="_IsG1EDvhEeePyrL5fVHxNw" name="Entry" isReentrant="false">
              <language>C++</language>
              <body>//0 = up&#xD;
//1 = down&#xD;
//2 = left&#xD;
//3 = right&#xD;&#xD;
int c = 0; &#xD;&#xD;
switch((c=fgetc(stdin))){&#xD;&#xD;
case 119:&#xD;
directions.directions(0).send();&#xD;
break;&#xD;
case 115:&#xD;
directions.directions(1).send();&#xD;
break;&#xD;
case 97:&#xD;
directions.directions(2).send();&#xD;
break;&#xD;
case 100:&#xD;
directions.directions(3).send();&#xD;
break;&#xD;
case 27:&#xD;
directions.exits().send();&#xD;
log.log(&quot;Exiting&quot;);&#xD;
flag = false;
break;
}&#xD;
timing.informIn(UMLRTTimespec(this->delay,0));</body>
            </entry>
          </subvertex>
          <subvertex xmi:type="uml:State" xmi:id="_sSwBYECXEeeKEZi9P2TNWQ" name="Waiting">
            <entry xmi:type="uml:OpaqueBehavior" xmi:id="_HOnzMETQEeem9u7KRr3TyA" name="Entry" isReentrant="false">
              <language>C++</language>
              <body></body>
            </entry>
          </subvertex>
        </region>
      </ownedBehavior>
    </packagedElement>
    <packagedElement xmi:type="uml:Class" xmi:id="_LFgVYDvhEeePyrL5fVHxNw" name="Calculation" classifierBehavior="_Iz1_UDviEeePyrL5fVHxNw" isActive="true">
      <ownedAttribute xmi:type="uml:Port" xmi:id="_s71WoDvhEeePyrL5fVHxNw" name="directions" visibility="public" type="_EpeekDmbEeetSfDhTP5ZLQ" isOrdered="true" aggregation="composite" isBehavior="true"/>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_s58_8DvkEeePyrL5fVHxNw" name="test" visibility="public" type="_NBM7IDvjEeePyrL5fVHxNw" isOrdered="true" aggregation="composite" isBehavior="true"/>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_lz21EDvmEeePyrL5fVHxNw" name="startR" visibility="private">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_lz21ETvmEeePyrL5fVHxNw" value="127"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_ms43cEAbEeecSdgC5rjddw" name="directions2" visibility="protected" type="_EpeekDmbEeetSfDhTP5ZLQ" isOrdered="true" aggregation="composite" isBehavior="true" isService="false"/>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_-4kuQETPEeem9u7KRr3TyA" name="log" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
        <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6kIb0IeXEeSVyrlWP4nYew"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_lDpBoGfvEee-Kre0NmQF5w" name="emptyR" visibility="private">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_lDpBoWfvEee-Kre0NmQF5w" value="255"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_XzqHYGfxEee-Kre0NmQF5w" name="map" visibility="private">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_kd4h0GfyEee-Kre0NmQF5w" name="flag" visibility="private">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Boolean"/>
        <defaultValue xmi:type="uml:LiteralBoolean" xmi:id="_rJv84GfyEee-Kre0NmQF5w"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_FrqjEGf4Eee-Kre0NmQF5w" name="x" visibility="private">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_JskMsGf4Eee-Kre0NmQF5w" name="y" visibility="private">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_KUyqUGf4Eee-Kre0NmQF5w" name="height" visibility="private">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_K5pD0Gf4Eee-Kre0NmQF5w" name="width" visibility="private">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_0vUoIG4VEeeUNoAgRbC5hw" name="observation" visibility="protected" type="_qQdckm4VEeeUNoAgRbC5hw" isOrdered="true" aggregation="composite" isBehavior="true" isService="false"/>
      <ownedBehavior xmi:type="uml:StateMachine" xmi:id="_Iz1_UDviEeePyrL5fVHxNw" name="CalculationStateMachine" isReentrant="false">
        <region xmi:type="uml:Region" xmi:id="_Iz97IDviEeePyrL5fVHxNw" name="Region">
          <transition xmi:type="uml:Transition" xmi:id="_I0LWgDviEeePyrL5fVHxNw" name="Initial" source="_I0CMkDviEeePyrL5fVHxNw" target="_I0I6QDviEeePyrL5fVHxNw">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_ou1lcEn9EeedZqJ4_o8GcQ" name="Effect" isReentrant="false">
              <language>C++</language>
              <body>map = imread(&quot;external_resources/map.png&quot;);&#xD;
width = map.size().width;&#xD;
height = map.size().height;&#xD;
&#xD;
</body>
            </effect>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_3rHdsEAcEeecSdgC5rjddw" name="" source="_I0I6QDviEeePyrL5fVHxNw" target="_smFqAEAcEeecSdgC5rjddw">
            <trigger xmi:type="uml:Trigger" xmi:id="_amvTEEAdEeecSdgC5rjddw" event="_XB7xgDvpEeePyrL5fVHxNw" port="_ms43cEAbEeecSdgC5rjddw"/>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_Nni1gGftEee-Kre0NmQF5w" name="" kind="external" source="_5hGJ0DvoEeePyrL5fVHxNw" target="_5hGJ0DvoEeePyrL5fVHxNw">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_O1jgwGftEee-Kre0NmQF5w" name="Effect" isReentrant="false">
              <language>C++</language>
              <body>//0 = up&#xD;
//1 = down&#xD;
//2 = left&#xD;
//3 = right&#xD;
&#xD;
if (Direction==0){&#xD;
x = X;
y = Y-1;&#xD;
} else if (Direction==1){&#xD;
x = X;
y = Y+1;&#xD;
} else if (Direction==2){&#xD;
x = X-1;
y = Y;&#xD;
} else if (Direction==3){&#xD;
x = X+1;
y = Y;&#xD;
}
Vec3b intensity = map.at&lt;Vec3b>(y, x);
if (intensity.val[2] == emptyR){
log.log(&quot;moved&quot;);
directions.directionCalc(x,y).send();
intensity.val[2]=startR;
map.at&lt;Vec3b>(Point(x,y)) = intensity;
Vec3b pIntensity = map.at&lt;Vec3b>(Y,X);
pIntensity.val[2]=emptyR;
map.at&lt;Vec3b>(Point(X,Y)) = pIntensity;

std::vector&lt;int> compression_params;
compression_params.push_back(CV_IMWRITE_PNG_COMPRESSION);
compression_params.push_back(9);

imwrite(&quot;external_resources/map.png&quot;, map, compression_params);

Event e1;
    e1.setSourceName(this->getName());
    e1.setParam(&quot;cmd&quot;, &quot;update&quot;);
    observation.event(e1).send();
} else {
log.log(&quot;wall&quot;);
directions.directionCalc(X,Y).send();
}


</body>
            </effect>
            <trigger xmi:type="uml:Trigger" xmi:id="_QSbHYGftEee-Kre0NmQF5w" event="_c26S8DmbEeetSfDhTP5ZLQ" port="_s71WoDvhEeePyrL5fVHxNw"/>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_cv8lwGfyEee-Kre0NmQF5w" name="" kind="external" source="_I0I6QDviEeePyrL5fVHxNw" target="_XrsowGfyEee-Kre0NmQF5w">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_h2g28GfyEee-Kre0NmQF5w" name="Effect" isReentrant="false">
              <language>C++</language>
              <body>Vec3b intensity = map.at&lt;Vec3b>(Y, X);
x = X;
y = Y;&#xD;flag = (intensity.val[2] == startR);
width = map.size().width;&#xD;
height = map.size().height;

</body>
            </effect>
            <trigger xmi:type="uml:Trigger" xmi:id="_d2IxwGfyEee-Kre0NmQF5w" event="_Wp6h0DvjEeePyrL5fVHxNw" port="_s58_8DvkEeePyrL5fVHxNw"/>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_2yuyMGfyEee-Kre0NmQF5w" name="found" guard="_7QNDEGfyEee-Kre0NmQF5w" kind="external" source="_XrsowGfyEee-Kre0NmQF5w" target="_5hGJ0DvoEeePyrL5fVHxNw">
            <ownedRule xmi:type="uml:Constraint" xmi:id="_7QNDEGfyEee-Kre0NmQF5w">
              <specification xmi:type="uml:OpaqueExpression" xmi:id="_7QNqIGfyEee-Kre0NmQF5w">
                <language>C++</language>
                <body>return flag;</body>
              </specification>
            </ownedRule>
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_WIAzAGfzEee-Kre0NmQF5w" name="Effect" isReentrant="false">
              <language>C++</language>
              <body>test.isStartOut(x,y).send();
flag = false;</body>
            </effect>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_9g89sGfyEee-Kre0NmQF5w" name="notFound" guard="_IUOTAGfzEee-Kre0NmQF5w" kind="external" source="_XrsowGfyEee-Kre0NmQF5w" target="_XrsowGfyEee-Kre0NmQF5w">
            <ownedRule xmi:type="uml:Constraint" xmi:id="_IUOTAGfzEee-Kre0NmQF5w">
              <specification xmi:type="uml:OpaqueExpression" xmi:id="_IUOTAWfzEee-Kre0NmQF5w">
                <language>C++</language>
                <body>return !flag;</body>
              </specification>
            </ownedRule>
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_HXMDAGfzEee-Kre0NmQF5w" name="Effect" isReentrant="false">
              <language>C++</language>
              <body>
if (x != width){&#xD;
x++;&#xD;
} else {&#xD;
if (y != height){&#xD;
y++;&#xD;
x = 0;&#xD;
}else{&#xD;
log.log(&quot;FAILURE&quot;);&#xD;
while(true){};&#xD;
}}
Vec3b intensity = map.at&lt;Vec3b>(y, x);&#xD;
flag = (intensity.val[2] == startR);</body>
            </effect>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_ETVbAGf0Eee-Kre0NmQF5w" name="" kind="external" source="_5hGJ0DvoEeePyrL5fVHxNw" target="_smFqAEAcEeecSdgC5rjddw">
            <trigger xmi:type="uml:Trigger" xmi:id="_KbvjsGf0Eee-Kre0NmQF5w" event="_XB7xgDvpEeePyrL5fVHxNw" port="_ms43cEAbEeecSdgC5rjddw"/>
          </transition>
          <subvertex xmi:type="uml:Pseudostate" xmi:id="_I0CMkDviEeePyrL5fVHxNw" name=""/>
          <subvertex xmi:type="uml:State" xmi:id="_I0I6QDviEeePyrL5fVHxNw" name="Waiting">
            <entry xmi:type="uml:OpaqueBehavior" xmi:id="_8bExEETPEeem9u7KRr3TyA" name="Entry" isReentrant="false">
              <language>C++</language>
              <body></body>
            </entry>
          </subvertex>
          <subvertex xmi:type="uml:State" xmi:id="_5hGJ0DvoEeePyrL5fVHxNw" name="CoordinateCalculater">
            <entry xmi:type="uml:OpaqueBehavior" xmi:id="_xAEb0En9EeedZqJ4_o8GcQ" name="Entry" isReentrant="false">
              <language>C++</language>
              <body></body>
            </entry>
          </subvertex>
          <subvertex xmi:type="uml:State" xmi:id="_smFqAEAcEeecSdgC5rjddw" name="Exited">
            <entry xmi:type="uml:OpaqueBehavior" xmi:id="_BQ60IEn-EeedZqJ4_o8GcQ" name="Entry" isReentrant="false">
              <language>C++</language>
              <body>log.log(&quot;calculation exit&quot;);</body>
            </entry>
          </subvertex>
          <subvertex xmi:type="uml:Pseudostate" xmi:id="_XrsowGfyEee-Kre0NmQF5w" name="" kind="choice"/>
        </region>
      </ownedBehavior>
    </packagedElement>
    <packagedElement xmi:type="uml:Package" xmi:id="_qQdckG4VEeeUNoAgRbC5hw" name="Observation">
      <packagedElement xmi:type="uml:Package" xmi:id="_qQdckW4VEeeUNoAgRbC5hw" name="Observation">
        <packagedElement xmi:type="uml:Collaboration" xmi:id="_qQdckm4VEeeUNoAgRbC5hw" name="Observation">
          <interfaceRealization xmi:type="uml:InterfaceRealization" xmi:id="_qQdck24VEeeUNoAgRbC5hw" client="_qQdckm4VEeeUNoAgRbC5hw" supplier="_qQdclW4VEeeUNoAgRbC5hw" contract="_qQdclW4VEeeUNoAgRbC5hw"/>
          <interfaceRealization xmi:type="uml:InterfaceRealization" xmi:id="_qQdclG4VEeeUNoAgRbC5hw" client="_qQdckm4VEeeUNoAgRbC5hw" supplier="_qQdcm24VEeeUNoAgRbC5hw" contract="_qQdcm24VEeeUNoAgRbC5hw"/>
        </packagedElement>
        <packagedElement xmi:type="uml:Interface" xmi:id="_qQdclW4VEeeUNoAgRbC5hw" name="Observation"/>
        <packagedElement xmi:type="uml:Interface" xmi:id="_qQdclm4VEeeUNoAgRbC5hw" name="Observation~">
          <ownedOperation xmi:type="uml:Operation" xmi:id="_qQdcl24VEeeUNoAgRbC5hw" name="event">
            <ownedParameter xmi:type="uml:Parameter" xmi:id="_qQdcmG4VEeeUNoAgRbC5hw" name="data" type="_qQdcu24VEeeUNoAgRbC5hw"/>
          </ownedOperation>
        </packagedElement>
        <packagedElement xmi:type="uml:Usage" xmi:id="_qQdcmW4VEeeUNoAgRbC5hw" client="_qQdckm4VEeeUNoAgRbC5hw" supplier="_qQdclm4VEeeUNoAgRbC5hw"/>
        <packagedElement xmi:type="uml:AnyReceiveEvent" xmi:id="_qQdcmm4VEeeUNoAgRbC5hw" name="*"/>
        <packagedElement xmi:type="uml:Interface" xmi:id="_qQdcm24VEeeUNoAgRbC5hw" name="ObservationIO"/>
        <packagedElement xmi:type="uml:Usage" xmi:id="_qQdcnG4VEeeUNoAgRbC5hw" client="_qQdckm4VEeeUNoAgRbC5hw" supplier="_qQdcm24VEeeUNoAgRbC5hw"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_qQdcnW4VEeeUNoAgRbC5hw" operation="_qQdcl24VEeeUNoAgRbC5hw"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="_qQdcnm4VEeeUNoAgRbC5hw" name="Observer" classifierBehavior="_qQdcpW4VEeeUNoAgRbC5hw" isActive="true">
        <ownedAttribute xmi:type="uml:Port" xmi:id="_qQdcn24VEeeUNoAgRbC5hw" name="observation" visibility="public" type="_qQdckm4VEeeUNoAgRbC5hw" isOrdered="true" aggregation="composite" isBehavior="true" isConjugated="true">
          <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_qQdcoG4VEeeUNoAgRbC5hw" value="20"/>
          <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_qQdcoW4VEeeUNoAgRbC5hw" value="20"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_qQdcom4VEeeUNoAgRbC5hw" name="log" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6kIb0IeXEeSVyrlWP4nYew"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_qQdco24VEeeUNoAgRbC5hw" name="config" visibility="public" type="_qQdctG4VEeeUNoAgRbC5hw"/>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_qQdcpG4VEeeUNoAgRbC5hw" name="timer" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedBehavior xmi:type="uml:StateMachine" xmi:id="_qQdcpW4VEeeUNoAgRbC5hw" name="ObserverStateMachine" isReentrant="false">
          <region xmi:type="uml:Region" xmi:id="_qQdcpm4VEeeUNoAgRbC5hw" name="Region">
            <transition xmi:type="uml:Transition" xmi:id="_qQdcp24VEeeUNoAgRbC5hw" name="configure" source="_qQdcr24VEeeUNoAgRbC5hw" target="_qQdcsG4VEeeUNoAgRbC5hw">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_qQdcqG4VEeeUNoAgRbC5hw">
                <language>C++</language>
                <body>config.load();&#xD;
&#xD;
// Socket&#xD;
this->method = new ClientSocket();&#xD;
this->method->configure(config.getConfigList());&#xD;
this->method->establishConnection();&#xD;
&#xD;
// Text &#xD;
this->serializer = new Text();&#xD;
this->serializer->configure(config.getConfigList());&#xD;
&#xD;
// Instantiating the timer&#xD;
timer.informEvery(UMLRTTimespec(0,500000000));</body>
              </effect>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_qQdcqW4VEeeUNoAgRbC5hw" source="_qQdcsG4VEeeUNoAgRbC5hw" target="_qQdcsG4VEeeUNoAgRbC5hw">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_qQdcqm4VEeeUNoAgRbC5hw">
                <language>C++</language>
                <body>    std::string str = this->serializer->serialize(data) + &quot;\n&quot;;
    this->method->sendData(str);
</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_qQdcq24VEeeUNoAgRbC5hw" event="_qQdcnW4VEeeUNoAgRbC5hw" port="_qQdcn24VEeeUNoAgRbC5hw"/>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_qQdcrG4VEeeUNoAgRbC5hw" name="read" source="_qQdcsG4VEeeUNoAgRbC5hw" target="_qQdcsG4VEeeUNoAgRbC5hw">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_qQdcrW4VEeeUNoAgRbC5hw">
                <language>C++</language>
                <body>    this->method->read();
</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_qQdcrm4VEeeUNoAgRbC5hw" port="_qQdcpG4VEeeUNoAgRbC5hw">
                <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
              </trigger>
            </transition>
            <subvertex xmi:type="uml:Pseudostate" xmi:id="_qQdcr24VEeeUNoAgRbC5hw">
              <name xsi:nil="true"/>
            </subvertex>
            <subvertex xmi:type="uml:State" xmi:id="_qQdcsG4VEeeUNoAgRbC5hw" name="OBSERVING"/>
          </region>
        </ownedBehavior>
      </packagedElement>
      <packagedElement xmi:type="uml:Package" xmi:id="_qQdcsW4VEeeUNoAgRbC5hw" name="internal">
        <packagedElement xmi:type="uml:Artifact" xmi:id="_qQdcsm4VEeeUNoAgRbC5hw" name="Method" fileName=""/>
        <packagedElement xmi:type="uml:Artifact" xmi:id="_qQdcs24VEeeUNoAgRbC5hw" name="Config" fileName=""/>
        <packagedElement xmi:type="uml:Class" xmi:id="_qQdctG4VEeeUNoAgRbC5hw" name="Config"/>
        <packagedElement xmi:type="uml:Artifact" xmi:id="_qQdctW4VEeeUNoAgRbC5hw" name="Serializer" fileName=""/>
        <packagedElement xmi:type="uml:Artifact" xmi:id="_qQdctm4VEeeUNoAgRbC5hw" name="Event" fileName=""/>
        <packagedElement xmi:type="uml:Artifact" xmi:id="_qQdct24VEeeUNoAgRbC5hw" name="Socket" fileName=""/>
        <packagedElement xmi:type="uml:Class" xmi:id="_qQdcuG4VEeeUNoAgRbC5hw" name="Socket"/>
        <packagedElement xmi:type="uml:Artifact" xmi:id="_qQdcuW4VEeeUNoAgRbC5hw" name="Text" fileName=""/>
        <packagedElement xmi:type="uml:Class" xmi:id="_qQdcum4VEeeUNoAgRbC5hw" name="Text"/>
        <packagedElement xmi:type="uml:Class" xmi:id="_qQdcu24VEeeUNoAgRbC5hw" name="Event"/>
        <packagedElement xmi:type="uml:Class" xmi:id="_qQdcvG4VEeeUNoAgRbC5hw" name="ClientSocket"/>
        <packagedElement xmi:type="uml:Artifact" xmi:id="_qQdcvW4VEeeUNoAgRbC5hw" name="ClientSocket" fileName=""/>
      </packagedElement>
      <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_qQdcvm4VEeeUNoAgRbC5hw">
        <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_qQdcv24VEeeUNoAgRbC5hw" source="http://www.eclipse.org/uml2/2.0.0/UML">
          <references xmi:type="ecore:EPackage" href="http://www.eclipse.org/papyrus/umlrt#/"/>
        </eAnnotations>
        <appliedProfile xmi:type="uml:Profile" href="pathmap://UML_RT_PROFILE/uml-rt.profile.uml#_1h74oEeVEeO0lv5O1DTHOQ"/>
      </profileApplication>
      <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_qQdcwG4VEeeUNoAgRbC5hw">
        <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_qQdcwW4VEeeUNoAgRbC5hw" source="http://www.eclipse.org/uml2/2.0.0/UML">
          <references xmi:type="ecore:EPackage" href="http://www.eclipse.org/papyrus/umlrt/cppproperties#/"/>
        </eAnnotations>
        <appliedProfile xmi:type="uml:Profile" href="pathmap://UMLRT_CPP/RTCppProperties.profile.uml#_vl5LALs8EeSTjNEQkASznQ"/>
      </profileApplication>
      <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_qQdcwm4VEeeUNoAgRbC5hw">
        <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_qQdcw24VEeeUNoAgRbC5hw" source="http://www.eclipse.org/uml2/2.0.0/UML">
          <references xmi:type="ecore:EPackage" href="http://www.eclipse.org/papyrus/umlrt/statemachine#/"/>
        </eAnnotations>
        <appliedProfile xmi:type="uml:Profile" href="pathmap://UML_RT_PROFILE/UMLRealTimeSM-addendum.profile.uml#_KLcn0FDtEeOA4ecmvfqvaw"/>
      </profileApplication>
    </packagedElement>
    <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_g0QeczbLEeeS0ZUearuafA">
      <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_g0QedDbLEeeS0ZUearuafA" source="http://www.eclipse.org/uml2/2.0.0/UML">
        <references xmi:type="ecore:EPackage" href="http://www.eclipse.org/papyrus/umlrt#/"/>
      </eAnnotations>
      <appliedProfile xmi:type="uml:Profile" href="pathmap://UML_RT_PROFILE/uml-rt.profile.uml#_1h74oEeVEeO0lv5O1DTHOQ"/>
    </profileApplication>
    <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_g0QedTbLEeeS0ZUearuafA">
      <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_g0QedjbLEeeS0ZUearuafA" source="http://www.eclipse.org/uml2/2.0.0/UML">
        <references xmi:type="ecore:EPackage" href="http://www.eclipse.org/papyrus/umlrt/statemachine#/"/>
      </eAnnotations>
      <appliedProfile xmi:type="uml:Profile" href="pathmap://UML_RT_PROFILE/UMLRealTimeSM-addendum.profile.uml#_KLcn0FDtEeOA4ecmvfqvaw"/>
    </profileApplication>
    <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_jIwgADtSEeejkKe0yPo-pQ">
      <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_jI5C4DtSEeejkKe0yPo-pQ" source="http://www.eclipse.org/uml2/2.0.0/UML">
        <references xmi:type="ecore:EPackage" href="pathmap://UML_PROFILES/Ecore.profile.uml#_z1OFcHjqEdy8S4Cr8Rc_NA"/>
      </eAnnotations>
      <appliedProfile xmi:type="uml:Profile" href="pathmap://UML_PROFILES/Ecore.profile.uml#_0"/>
    </profileApplication>
    <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_x37eMDvWEeeVBItGYDMaLQ">
      <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_x4AWsDvWEeeVBItGYDMaLQ" source="http://www.eclipse.org/uml2/2.0.0/UML">
        <references xmi:type="ecore:EPackage" href="http://www.eclipse.org/papyrus/umlrt/cppproperties#/"/>
      </eAnnotations>
      <appliedProfile xmi:type="uml:Profile" href="pathmap://UMLRT_CPP/RTCppProperties.profile.uml#_vl5LALs8EeSTjNEQkASznQ"/>
    </profileApplication>
    <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_zKMYoEt_EeeD4eyKVO2S_Q">
      <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_zLdj8Et_EeeD4eyKVO2S_Q" source="http://www.eclipse.org/uml2/2.0.0/UML">
        <references xmi:type="ecore:EPackage" href="pathmap://PAPYRUS_ACTIONLANGUAGE_PROFILE/ActionLanguage-Profile.profile.uml#_Kv8EIKFXEeS_KNX0nfvIVQ"/>
      </eAnnotations>
      <appliedProfile xmi:type="uml:Profile" href="pathmap://PAPYRUS_ACTIONLANGUAGE_PROFILE/ActionLanguage-Profile.profile.uml#ActionLanguage"/>
    </profileApplication>
  </uml:Model>
  <UMLRealTime:Capsule xmi:id="_CFgKwDbOEeeS0ZUearuafA" base_Class="_B6RyMDbOEeeS0ZUearuafA"/>
  <UMLRealTime:Capsule xmi:id="_9zOAwDbOEeeS0ZUearuafA" base_Class="_9yzxEDbOEeeS0ZUearuafA"/>
  <UMLRealTime:RTPort xmi:id="_XuhsMDbPEeeS0ZUearuafA" isWired="false" base_Port="_XtyFUDbPEeeS0ZUearuafA"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_cPG7cDbPEeeS0ZUearuafA" base_Pseudostate="_cPCC8DbPEeeS0ZUearuafA"/>
  <UMLRTStateMachines:RTState xmi:id="_cPYBMDbPEeeS0ZUearuafA" base_State="_cPUW0DbPEeeS0ZUearuafA"/>
  <UMLRTStateMachines:RTRegion xmi:id="_cPnRwDbPEeeS0ZUearuafA" base_Region="_cO45ADbPEeeS0ZUearuafA"/>
  <UMLRTStateMachines:RTStateMachine xmi:id="_cQv6MDbPEeeS0ZUearuafA" base_StateMachine="_cOGO0DbPEeeS0ZUearuafA"/>
  <UMLRealTime:RTPort xmi:id="_lIjewDeHEee0Cb7xo9L6qw" isPublish="true" isWired="false" base_Port="_lIhCgDeHEee0Cb7xo9L6qw"/>
  <UMLRealTime:CapsulePart xmi:id="_SQKGkDliEeeHA4oSpVV8Ow" base_Property="_SQAVkDliEeeHA4oSpVV8Ow"/>
  <UMLRTStateMachines:RTState xmi:id="_KertgDmSEeetSfDhTP5ZLQ" base_State="_Kep4UDmSEeetSfDhTP5ZLQ"/>
  <UMLRealTime:ProtocolContainer xmi:id="_Epg60DmbEeetSfDhTP5ZLQ" base_Package="_EpgTwDmbEeetSfDhTP5ZLQ"/>
  <UMLRealTime:RTMessageSet xmi:id="_EpiwADmbEeetSfDhTP5ZLQ" base_Interface="_Ephh4DmbEeetSfDhTP5ZLQ"/>
  <UMLRealTime:RTMessageSet xmi:id="_Epj-IDmbEeetSfDhTP5ZLQ" base_Interface="_EpjXEDmbEeetSfDhTP5ZLQ" rtMsgKind="out"/>
  <UMLRealTime:RTMessageSet xmi:id="_EplzUDmbEeetSfDhTP5ZLQ" base_Interface="_EplMQDmbEeetSfDhTP5ZLQ" rtMsgKind="inOut"/>
  <UMLRealTime:Protocol xmi:id="_EpnBcDmbEeetSfDhTP5ZLQ" base_Collaboration="_EpeekDmbEeetSfDhTP5ZLQ"/>
  <UMLRealTime:Capsule xmi:id="__8C0ODmcEeetSfDhTP5ZLQ" base_Class="__7sO4DmcEeetSfDhTP5ZLQ"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_HTaJoDppEeehJIRyir005Q" base_Pseudostate="_HTXtYDppEeehJIRyir005Q"/>
  <UMLRTStateMachines:RTState xmi:id="_HTdM8DppEeehJIRyir005Q" base_State="_HTb-0DppEeehJIRyir005Q"/>
  <UMLRTStateMachines:RTRegion xmi:id="_HTebEDppEeehJIRyir005Q" base_Region="_HTUDADppEeehJIRyir005Q"/>
  <UMLRTStateMachines:RTStateMachine xmi:id="_HUiLADppEeehJIRyir005Q" base_StateMachine="_HTMHMDppEeehJIRyir005Q"/>
  <UMLRealTime:Capsule xmi:id="_JMnCsDs0Eee4vrzjGIvOwQ" base_Class="_JK_5IDs0Eee4vrzjGIvOwQ"/>
  <UMLRealTime:CapsulePart xmi:id="___b2kDs1Eee4vrzjGIvOwQ" base_Property="___ZaUDs1Eee4vrzjGIvOwQ"/>
  <UMLRealTime:RTPort xmi:id="_HBPk0DvYEeeVBItGYDMaLQ" base_Port="_HBMhgDvYEeeVBItGYDMaLQ"/>
  <UMLRealTime:RTPort xmi:id="_JOxMUDvYEeeVBItGYDMaLQ" isWired="false" base_Port="_JOth8DvYEeeVBItGYDMaLQ"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_Q-BXADvYEeeVBItGYDMaLQ" base_Pseudostate="_Q9-TsDvYEeeVBItGYDMaLQ"/>
  <UMLRTStateMachines:RTState xmi:id="_Q-GPgDvYEeeVBItGYDMaLQ" base_State="_Q-DzQDvYEeeVBItGYDMaLQ"/>
  <UMLRTStateMachines:RTRegion xmi:id="_Q-IEsDvYEeeVBItGYDMaLQ" base_Region="_Q96pUDvYEeeVBItGYDMaLQ"/>
  <UMLRTStateMachines:RTStateMachine xmi:id="_Q_KmgDvYEeeVBItGYDMaLQ" base_StateMachine="_Q9xfYDvYEeeVBItGYDMaLQ"/>
  <UMLRealTime:Capsule xmi:id="_LG9t8DvhEeePyrL5fVHxNw" base_Class="_LFgVYDvhEeePyrL5fVHxNw"/>
  <UMLRealTime:RTPort xmi:id="_s795gDvhEeePyrL5fVHxNw" base_Port="_s71WoDvhEeePyrL5fVHxNw"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_I0HFEDviEeePyrL5fVHxNw" base_Pseudostate="_I0CMkDviEeePyrL5fVHxNw"/>
  <UMLRTStateMachines:RTState xmi:id="_I0KvcDviEeePyrL5fVHxNw" base_State="_I0I6QDviEeePyrL5fVHxNw"/>
  <UMLRTStateMachines:RTRegion xmi:id="_I0MkoDviEeePyrL5fVHxNw" base_Region="_Iz97IDviEeePyrL5fVHxNw"/>
  <UMLRTStateMachines:RTStateMachine xmi:id="_I0wlUDviEeePyrL5fVHxNw" base_StateMachine="_Iz1_UDviEeePyrL5fVHxNw"/>
  <UMLRealTime:ProtocolContainer xmi:id="_NBX6QDvjEeePyrL5fVHxNw" base_Package="_NBRMkDvjEeePyrL5fVHxNw"/>
  <UMLRealTime:RTMessageSet xmi:id="_NBdZ0DvjEeePyrL5fVHxNw" base_Interface="_NBZIYDvjEeePyrL5fVHxNw"/>
  <UMLRealTime:RTMessageSet xmi:id="_NBhEMDvjEeePyrL5fVHxNw" base_Interface="_NBf2EDvjEeePyrL5fVHxNw" rtMsgKind="out"/>
  <UMLRealTime:RTMessageSet xmi:id="_NBmjwDvjEeePyrL5fVHxNw" base_Interface="_NBkHgDvjEeePyrL5fVHxNw" rtMsgKind="inOut"/>
  <UMLRealTime:Protocol xmi:id="_NBpAADvjEeePyrL5fVHxNw" base_Collaboration="_NBM7IDvjEeePyrL5fVHxNw"/>
  <UMLRealTime:CapsulePart xmi:id="_hV3RsDvkEeePyrL5fVHxNw" base_Property="_hV01cDvkEeePyrL5fVHxNw"/>
  <UMLRealTime:RTPort xmi:id="_s5_cMDvkEeePyrL5fVHxNw" base_Port="_s58_8DvkEeePyrL5fVHxNw"/>
  <UMLRealTime:CapsulePart xmi:id="_0JbeYDvkEeePyrL5fVHxNw" base_Property="_0JZCIDvkEeePyrL5fVHxNw"/>
  <UMLRealTime:RTPort xmi:id="_rauMYDvlEeePyrL5fVHxNw" isWired="false" base_Port="_raos0DvlEeePyrL5fVHxNw"/>
  <UMLRealTime:RTPort xmi:id="_BJ2yUDvmEeePyrL5fVHxNw" base_Port="_BJxSwDvmEeePyrL5fVHxNw"/>
  <UMLRealTime:RTPort xmi:id="_MRFlcDvmEeePyrL5fVHxNw" isWired="false" base_Port="_MRDJMDvmEeePyrL5fVHxNw"/>
  <UMLRTStateMachines:RTState xmi:id="_5hH_ADvoEeePyrL5fVHxNw" base_State="_5hGJ0DvoEeePyrL5fVHxNw"/>
  <UMLRTStateMachines:RTState xmi:id="_evPmADvqEeePyrL5fVHxNw" base_State="_evMisDvqEeePyrL5fVHxNw"/>
  <UMLRealTime:RTPort xmi:id="_17jUkDvqEeePyrL5fVHxNw" isWired="false" base_Port="_17g4UDvqEeePyrL5fVHxNw"/>
  <UMLRTStateMachines:RTState xmi:id="_T7Sh8DvvEeePyrL5fVHxNw" base_State="_T7QswDvvEeePyrL5fVHxNw"/>
  <RTCppProperties:CapsuleProperties xmi:id="_kMQSMDvzEeePyrL5fVHxNw" implementationPreface="#include &lt;stdio.h>&#xD;&#xA;#include &lt;iostream>&#xD;&#xA;using namespace std;&#xD;&#xA;" base_Class="_JK_5IDs0Eee4vrzjGIvOwQ"/>
  <UMLRealTime:RTPort xmi:id="_qi-6ADwPEeez78_2BqgPcw" base_Port="_qi3lQDwPEeez78_2BqgPcw"/>
  <UMLRealTime:RTConnector xmi:id="_vFNIADwPEeez78_2BqgPcw" base_Connector="_vFI2kDwPEeez78_2BqgPcw"/>
  <UMLRealTime:RTPort xmi:id="_1_c4AEAaEeecSdgC5rjddw" isPublish="true" isWired="false" base_Port="_144V8EAaEeecSdgC5rjddw"/>
  <UMLRealTime:RTPort xmi:id="_mtJWIEAbEeecSdgC5rjddw" isWired="false" base_Port="_ms43cEAbEeecSdgC5rjddw"/>
  <UMLRealTime:RTPort xmi:id="_Uo-woEAcEeecSdgC5rjddw" isWired="false" base_Port="_UouR8EAcEeecSdgC5rjddw"/>
  <UMLRTStateMachines:RTState xmi:id="_ZzzPsEAcEeecSdgC5rjddw" base_State="_ZzlNQEAcEeecSdgC5rjddw"/>
  <UMLRTStateMachines:RTState xmi:id="_smSeUEAcEeecSdgC5rjddw" base_State="_smFqAEAcEeecSdgC5rjddw"/>
  <UMLRealTime:RTConnector xmi:id="_oJRHIEAhEeecSdgC5rjddw" base_Connector="_oJDrwEAhEeecSdgC5rjddw"/>
  <UMLRealTime:RTPort xmi:id="_OpAVUECXEeeKEZi9P2TNWQ" isWired="false" base_Port="_Oo8q8ECXEeeKEZi9P2TNWQ"/>
  <UMLRTStateMachines:RTState xmi:id="_sSzEsECXEeeKEZi9P2TNWQ" base_State="_sSwBYECXEeeKEZi9P2TNWQ"/>
  <UMLRealTime:RTPort xmi:id="_-5iXkETPEeem9u7KRr3TyA" isWired="false" base_Port="_-4kuQETPEeem9u7KRr3TyA"/>
  <UMLRealTime:RTPort xmi:id="_wIU8UETrEeem9u7KRr3TyA" base_Port="_wEmS4ETrEeem9u7KRr3TyA"/>
  <UMLRealTime:RTConnector xmi:id="_Or-r4ETsEeem9u7KRr3TyA" base_Connector="_Od3XYETsEeem9u7KRr3TyA"/>
  <ActionLanguage:TextualRepresentation xmi:id="_zVSOUEt_EeeD4eyKVO2S_Q" base_Comment="_y-eQ0Et_EeeD4eyKVO2S_Q" language="org.eclipse.papyrus.uml.textedit.state.xtext.UmlState"/>
  <UMLRTStateMachines:RTState xmi:id="_5YYYEGftEee-Kre0NmQF5w" base_State="_5YWi4GftEee-Kre0NmQF5w"/>
  <RTCppProperties:CapsuleProperties xmi:id="_q_ffkGfwEee-Kre0NmQF5w" headerPreface="#include &lt;vector>&#xA;#include &quot;external_resources/opencv/sources/modules/core/include/opencv2/core.hpp&quot;&#xA;#include &quot;external_resources/opencv/sources/modules/highgui/include/opencv2/highgui.hpp&quot;&#xA;#include &quot;external_resources/opencv/sources/modules/imgcodecs/include/opencv2/imgcodecs.hpp&quot;&#xA;#include &quot;external_resources/opencv/sources/modules/imgproc/include/opencv2/imgproc.hpp&quot;&#xA;using namespace cv;" implementationPreface="#include &quot;external_resources/opencv/sources/modules/core/include/opencv2/core.hpp&quot;&#xA;#include &quot;external_resources/opencv/sources/modules/highgui/include/opencv2/highgui.hpp&quot;&#xA;#include &quot;external_resources/opencv/sources/modules/imgcodecs/include/opencv2/imgcodecs.hpp&quot;&#xA;#include &quot;external_resources/opencv/sources/modules/imgproc/include/opencv2/imgproc.hpp&quot;&#xA;using namespace cv;" base_Class="_LFgVYDvhEeePyrL5fVHxNw"/>
  <RTCppProperties:AttributeProperties xmi:id="_XzrVgGfxEee-Kre0NmQF5w" type="Mat" base_Property="_XzqHYGfxEee-Kre0NmQF5w"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_Xrw6MGfyEee-Kre0NmQF5w" base_Pseudostate="_XrsowGfyEee-Kre0NmQF5w"/>
  <UMLRealTime:ProtocolContainer xmi:id="_qQfRwG4VEeeUNoAgRbC5hw" base_Package="_qQdckW4VEeeUNoAgRbC5hw"/>
  <UMLRealTime:Protocol xmi:id="_qQkxUG4VEeeUNoAgRbC5hw" base_Collaboration="_qQdckm4VEeeUNoAgRbC5hw"/>
  <UMLRealTime:RTMessageSet xmi:id="_qQlYYG4VEeeUNoAgRbC5hw" base_Interface="_qQdclW4VEeeUNoAgRbC5hw"/>
  <UMLRealTime:RTMessageSet xmi:id="_qQlYYW4VEeeUNoAgRbC5hw" base_Interface="_qQdclm4VEeeUNoAgRbC5hw" rtMsgKind="out"/>
  <UMLRealTime:RTMessageSet xmi:id="_qQl_cG4VEeeUNoAgRbC5hw" base_Interface="_qQdcm24VEeeUNoAgRbC5hw" rtMsgKind="inOut"/>
  <UMLRealTime:Capsule xmi:id="_qQmmgG4VEeeUNoAgRbC5hw" base_Class="_qQdcnm4VEeeUNoAgRbC5hw"/>
  <RTCppProperties:CapsuleProperties xmi:id="_qQmmgW4VEeeUNoAgRbC5hw" headerPreface="#include &quot;Method.hh&quot;&#xD;&#xA;#include &quot;Socket.hh&quot;&#xD;&#xA;#include &quot;ClientSocket.hh&quot;&#xD;&#xA;#include &quot;Serializer.hh&quot;&#xD;&#xA;#include &quot;Text.hh&quot;" base_Class="_qQdcnm4VEeeUNoAgRbC5hw" privateDeclarations="Method* method;&#xA;Serializer* serializer;"/>
  <UMLRealTime:RTPort xmi:id="_qQnNkG4VEeeUNoAgRbC5hw" isNotification="false" isPublish="true" isWired="false" registration="Automatic" registrationOverride="" base_Port="_qQdcn24VEeeUNoAgRbC5hw"/>
  <UMLRealTime:RTPort xmi:id="_qQn0oG4VEeeUNoAgRbC5hw" isNotification="false" isPublish="false" isWired="false" registration="Automatic" registrationOverride="" base_Port="_qQdcom4VEeeUNoAgRbC5hw"/>
  <UMLRealTime:RTPort xmi:id="_qQobsG4VEeeUNoAgRbC5hw" isNotification="false" isPublish="false" isWired="false" registration="Automatic" registrationOverride="" base_Port="_qQdcpG4VEeeUNoAgRbC5hw"/>
  <UMLRTStateMachines:RTStateMachine xmi:id="_qQpCwG4VEeeUNoAgRbC5hw" base_StateMachine="_qQdcpW4VEeeUNoAgRbC5hw"/>
  <UMLRTStateMachines:RTRegion xmi:id="_qQpCwW4VEeeUNoAgRbC5hw" base_Region="_qQdcpm4VEeeUNoAgRbC5hw"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_qQpp0G4VEeeUNoAgRbC5hw" base_Pseudostate="_qQdcr24VEeeUNoAgRbC5hw"/>
  <UMLRTStateMachines:RTState xmi:id="_qQqQ4G4VEeeUNoAgRbC5hw" base_State="_qQdcsG4VEeeUNoAgRbC5hw"/>
  <RTCppProperties:ArtifactProperties xmi:id="_qQq38G4VEeeUNoAgRbC5hw" base_Artifact="_qQdcsm4VEeeUNoAgRbC5hw" includeFile="#include &lt;map>&#xD;&#xA;#include &lt;string>&#xD;&#xA;&#xD;&#xA;class Method {&#xD;&#xA;&#xD;&#xA;    public:&#xD;&#xA;        Method();&#xD;&#xA;        virtual ~Method();&#xD;&#xA;        virtual void configure(std::map&lt;std::string, std::string> configList) = 0;&#xD;&#xA;        virtual const bool canConnect() const;&#xD;&#xA;        virtual int establishConnection() = 0;&#xD;&#xA;        virtual void disconnect() = 0;&#xD;&#xA;        virtual void read() = 0;&#xD;&#xA;        virtual void sendData(std::string) = 0;&#xD;&#xA;        virtual const std::string getConfig(std::map&lt;std::string, std::string> configList, std::string key) const;&#xD;&#xA;};" sourceFile="#include &lt;stdio.h>&#xA;&#xA;Method::Method() {&#xA;}&#xA;&#xA;Method::~Method() {&#xA;}&#xA;&#xA;const bool Method::canConnect() const {&#xA;    return false;&#xA;}&#xA;&#xA;const std::string Method::getConfig(std::map&lt;std::string, std::string> configList, std::string key) const {&#xA;&#x9;bool n = configList.count(key);&#xA;&#x9;return (n) ? configList.at(key) : &quot;&quot;;&#xA;}"/>
  <RTCppProperties:ArtifactProperties xmi:id="_qQrfAG4VEeeUNoAgRbC5hw" base_Artifact="_qQdcs24VEeeUNoAgRbC5hw" includeFile="#include &lt;string>&#xA;#include &lt;map>&#xA;&#xA;class Config {&#xA;&#xA;    private:&#xA;        std::string configFileName;&#xA;        std::string fieldSeparator;&#xA;        std::string commentStr;&#xA;        std::string getConfigPath();&#xA;&#x9;&#x9;std::map&lt;std::string,std::string> configList;&#xA;&#xA;    public:&#xA;        Config();&#xA;        ~Config();&#xA;        int load();&#xA;&#x9;&#x9;void append(std::string key, std::string value);&#xA;&#x9;&#x9;std::string get(std::string key);&#xA;        void setConfigFileName(const std::string configFileName);&#xA;        const std::string getConfigFileName() const;&#xA;&#xA;        void setFieldSeparator(const std::string fieldSeparator);&#xA;        const std::string getFieldSeparator() const;&#xA;&#xA;        void setCommentStr(const std::string commentStr);&#xA;        const std::string getCommentStr() const;&#xA;&#xA;&#x9;&#x9;const std::map&lt;std::string,std::string> getConfigList() const;&#xA;};" sourceFile="#include &lt;stdio.h>&#xA;#include &lt;fstream>&#xA;#include &lt;iostream>&#xA;#include &lt;unistd.h>&#xA;&#xA;using namespace std;&#xA;&#xA;Config::Config() {&#xA;    this->setConfigFileName(&quot;config&quot;);&#xA;    this->setFieldSeparator(&quot;=&quot;);&#xA;    this->setCommentStr(&quot;#&quot;);&#xA;}&#xA;&#xA;Config::~Config() {&#xA;}&#xA;&#xA;int Config::load() {&#xA;&#xA;    int result = 0;&#xA;    std::string prefix = &quot;&quot;;&#xA;    std::string configPath = this->getConfigPath();&#xA;    std::ifstream configFile(configPath.c_str());&#xA;    std::string line;&#xA;&#xA;    if (configFile.is_open()) {&#xA;        while (std::getline(configFile, line)) {&#xA;&#xA;&#x9;&#x9;&#x9;std::string key, value;&#xA;&#xA;            // skip the space and comment line&#xA;            std::string::size_type nonSpaceCharIndex = line.find_first_not_of(&quot; \f\t\v&quot;);&#xA;&#x9;&#x9;&#x9;if (nonSpaceCharIndex == std::string::npos)&#xA;&#x9;&#x9;&#x9;&#x9;continue; // line is empty, skp it&#xA;&#xA;&#x9;&#x9;&#x9;if (this->commentStr.find(line[nonSpaceCharIndex]) != std::string::npos)&#xA;&#x9;&#x9;&#x9;&#x9;continue; // skip the line , it is a comment line&#xA;&#xA;            // Check if it is a definition of a specific rule&#xA;            std::string::size_type prefixIndex = line.find(&quot;[&quot;, nonSpaceCharIndex);&#xA;            if (prefixIndex != std::string::npos) {&#xA;&#xA;                std::string::size_type valueNonSpaceCharIndex = line.find_first_not_of(&quot; \f\t\v&quot;, prefixIndex + 1);&#xA;                std::string p = line.substr(valueNonSpaceCharIndex);&#xA;                p.erase(p.find_last_not_of(&quot; \f\t\v&quot;));&#xA;                p.erase(p.find_last_not_of(&quot; \f\t\v&quot;) + 1);&#xA;                prefix = p;&#xA;                continue;&#xA;&#x9;&#x9;&#x9;}&#xA;            &#xA;&#x9;&#x9;&#x9;// extract key value&#xA;&#x9;&#x9;&#x9;std::string::size_type sepIndex = line.find(this->getFieldSeparator(), nonSpaceCharIndex);&#xA;&#x9;&#x9;&#x9;if (sepIndex == std::string::npos)&#xA;&#x9;&#x9;&#x9;&#x9;continue; // the line doesn't contain the seperator&#xA;&#xA;&#x9;&#x9;&#x9;key = line.substr(nonSpaceCharIndex, sepIndex - nonSpaceCharIndex);&#xA;&#x9;&#x9;&#x9;key.erase(key.find_last_not_of(&quot; \f\t\v&quot;) + 1);&#xA;&#xA;&#x9;&#x9;&#x9;if (key.empty())&#xA;&#x9;&#x9;&#x9;&#x9;continue; // the kwy should have value&#xA;&#xA;            if (sepIndex + 1 == line.length())&#xA;                continue; // there is no value&#xA;&#xA;&#x9;&#x9;&#x9;/// extract the value&#xA;&#x9;&#x9;&#x9;std::string::size_type valueNonSpaceCharIndex = line.find_first_not_of(&quot; \f\t\v&quot;, sepIndex + 1);&#xA;&#xA;            if (valueNonSpaceCharIndex == std::string::npos)&#xA;                continue; // there is no value&#xA;&#xA;&#xA;&#x9;&#x9;&#x9;std::string::size_type valueLastNonSpaceCharIndex = line.find_last_not_of(&quot; \f\t\v&quot;);&#xA;&#x9;&#x9;&#x9;value = line.substr(valueNonSpaceCharIndex, valueLastNonSpaceCharIndex - valueNonSpaceCharIndex + 1);&#xA;            if (!prefix.empty())&#xA;                key = prefix + &quot;.&quot; + key;&#xA;&#x9;&#x9;&#x9;this->append(key,value);&#xA;            printf(&quot;%s=%s\n&quot;, key.c_str(), value.c_str());&#xA;&#x9;&#x9;&#x9;result = result + 1;&#xA;        }&#xA;    }&#xA;    else {&#xA;    //    std::cerr &lt;&lt; &quot;Error in reading configuration file from &quot; &lt;&lt; configPath &lt;&lt; std::endl;&#xA;        result=-1;&#xA;    }&#xA;&#x9;configFile.close();&#xA;    return result;&#xA;}&#xA;&#xA;void Config::append(std::string key, std::string value) {&#xA;&#x9;if (!key.empty())&#xA;&#x9;&#x9;this->configList[key] = value;&#xA;}&#xA;&#xA;std::string Config::get(std::string key) {&#xA;&#x9;bool n = this->configList.count(key);&#xA;&#x9;return (n) ? this->configList.at(key) : &quot;&quot;;&#xA;}&#xA;&#xA;/**&#xA; * Resolve the full path from the exec path&#xA; */&#xA;std::string Config::getConfigPath() {&#xA;&#xA;&#x9;char result[255];&#xA;    std::string path;&#xA;&#xA;&#x9;readlink(&quot;/proc/self/exe&quot;, result, 255);&#xA;&#x9;path = std::string(result);&#xA;&#xA;    // find the last &quot;/&quot; position&#xA;&#x9;size_t n = path.rfind('/');&#xA;&#xA;    // remove the last fragment of the path&#xA;    path = (n > 0) ? path.substr(0, n) : &quot;&quot;;&#xA;&#xA;    // return the full path&#xA;    return (path != &quot;&quot;) ? path + &quot;/&quot; + this->configFileName : this->configFileName;&#xA;}&#xA;&#xA;void Config::setConfigFileName(const std::string configFileName) {&#xA;    this->configFileName = configFileName;&#xA;}&#xA;&#xA;const std::string Config::getConfigFileName() const {&#xA;    return this->configFileName;&#xA;}&#xA;&#xA;void Config::setFieldSeparator(const std::string fieldSeparator) {&#xA;    this->fieldSeparator = fieldSeparator;&#xA;}&#xA;&#xA;const std::string Config::getFieldSeparator() const {&#xA;    return this->fieldSeparator;&#xA;}&#xA;&#xA;&#xA;void Config::setCommentStr(const std::string commentStr) {&#xA;    this->commentStr = commentStr;&#xA;}&#xA;&#xA;const std::string Config::getCommentStr() const {&#xA;    return this->commentStr;&#xA;}&#xA;&#xA;const std::map&lt;std::string,std::string> Config::getConfigList() const {&#xA;&#x9;return this->configList;&#xA;}"/>
  <RTCppProperties:PassiveClassProperties xmi:id="_qQstIG4VEeeUNoAgRbC5hw" base_Class="_qQdctG4VEeeUNoAgRbC5hw" generate="false"/>
  <RTCppProperties:ArtifactProperties xmi:id="_qQt7QG4VEeeUNoAgRbC5hw" base_Artifact="_qQdctW4VEeeUNoAgRbC5hw" includeFile="#include &lt;map>&#xA;#include &lt;string>&#xA;#include &quot;Event.hh&quot;&#xA;&#xA;class Serializer {&#xA;&#xA;    public:&#xA;        Serializer();&#xA;        virtual ~Serializer();&#xA;        virtual void configure(std::map&lt;std::string, std::string> configList) = 0;&#xA;        virtual const std::string serialize(const Event event) const = 0;&#xA;        virtual Event parse(const std::string data) const = 0;&#xA;        virtual const std::string getConfig(std::map&lt;std::string, std::string> configList, std::string key) const;&#xA;};" sourceFile="Serializer::Serializer() {&#xA;}&#xA;&#xA;Serializer::~Serializer() {&#xA;}&#xA;&#xA;const std::string Serializer::getConfig(std::map&lt;std::string, std::string> configList, std::string key) const {&#xA;&#x9;bool n = configList.count(key);&#xA;&#x9;return (n) ? configList.at(key) : &quot;&quot;;&#xA;}"/>
  <RTCppProperties:ArtifactProperties xmi:id="_qQt7QW4VEeeUNoAgRbC5hw" base_Artifact="_qQdctm4VEeeUNoAgRbC5hw" includeFile="#include &lt;map>&#xA;#include &lt;iostream>&#xA;#include &lt;string.h>&#xA;#include &lt;sstream>&#xA;#include &lt;stdio.h>&#xA;#include &lt;stdlib.h>&#xA;#include &lt;vector>&#xA;#include &quot;umlrtobjectclass.hh&quot;&#xA;&#xA;&#xA;class Event {&#xA;&#xA;&#xA;&#xA;    public:&#xA;        typedef enum {&#xA;            Signal, Method, ActionCode, Transition, State, Capsule, Attribute, Timer, UnknownSource&#xA;        } EventSource; &#xA;&#xA;        typedef enum {&#xA;            SendSignal, ReceiveSignal, DeferSignal, RecallSignal, CancelSignal, // Signal events&#xA;            MethodCall, MethodCallReceive, MethodStartExecute, MethodReturn, MethodFailed, MethodReturnReceived, // Method events&#xA;            ActionStart, ActionEnd, // Action code events&#xA;            TransitionStart, TransitionEnd, // Transition events&#xA;            StateEntryStart, StateEntryEnd, StateExitStart, StateExitEnd, StateIdleStart, StateIdleEnd, // State events&#xA;            CapsuleInstantiate, CapsuleFree, // Capsule events&#xA;            AttributeInstantiate, AttributeFree, AttributeChange, // Attribute events&#xA;            TimerStart, TimerSet, TimerCancel, TimerTimeout, // Timer events&#xA;            UnknownKind&#xA;        } EventKind;&#xA;&#xA;    private:&#xA;        std::string capsuleInstance;&#xA;        std::string sourceName;&#xA;        std::string eventId;&#xA;        long seconds;&#xA;        long nanoseconds;&#xA;        EventSource eventSource;&#xA;        EventKind eventKind;&#xA;        std::map&lt;std::string, std::string> params;&#xA;&#xA;    public:&#xA;        Event(std::string capsuleInstance = &quot;&quot;,&#xA;              std::string sourceName = &quot;&quot;,&#xA;              EventSource eventSource = UnknownSource,&#xA;              EventKind eventKind = UnknownKind,&#xA;              long seconds = 0,&#xA;              long nanoseconds = 0);&#xA;        const std::string getCapsuleInstance() const;&#xA;        void setCapsuleInstance(const std::string capsuleInstance);&#xA;        const std::string getSourceName() const;&#xA;        void setSourceName(const std::string sourceName);&#xA;        const EventSource getEventSource() const;&#xA;        void setEventSource(const Event::EventSource source);&#xA;        const EventKind getEventKind() const;&#xA;        void setEventKind(const Event::EventKind kind);&#xA;        const long getSeconds() const;&#xA;        const long getNanoseconds() const;&#xA;        void setTimestamp();&#xA;        void setTimestamp(const long seconds, const long nanoseconds = 0);&#xA;        void setSeconds(const long seconds);&#xA;        void setNanoseconds(const long nanoseconds = 0);&#xA;        void setEventId(const std::string eventId);&#xA;        const std::string getEventId() const;&#xA;        void generateEventId();&#xA;        const std::map&lt;std::string, std::string> getParams() const;&#xA;        const std::string getParam(std::string key) const;&#xA;        void setParams(const std::map&lt;std::string, std::string> params);&#xA;        void setParam(const  std::string key, const std::string value);&#xA;&#x9;void setParam(const  std::string key, const int value);&#xA;        void clearParams();&#xA;&#x9;static const UMLRTObject_field fields[];&#xA;};&#xA;&#xA;extern const UMLRTObject_class UMLRTType_Event;&#xA;" sourceFile="#include &lt;string>&#xA;#include &lt;sstream>&#xA;#include &lt;time.h>&#xA;#include &lt;sys/time.h>&#xA;#include &lt;stdio.h>&#xA;#include &lt;stdlib.h>&#xA;#include &quot;umlrtobjectclass.hh&quot;&#xA;#include &quot;umlrtobjectclassgeneric.hh&quot;&#xA;&#xA;const UMLRTObject_field Event::fields[] = &#xA;{&#xA;};&#xA;&#xA;&#xA;&#xA;Event::Event(std::string capsuleInstance,&#xA;      std::string sourceName,&#xA;      EventSource eventSource,&#xA;      EventKind eventKind,&#xA;      long seconds,&#xA;      long nanoseconds) {&#xA;&#xA;    this->generateEventId();&#xA;    this->setCapsuleInstance(capsuleInstance);&#xA;    this->setSourceName(sourceName);&#xA;    this->setEventSource(eventSource);&#xA;    this->setEventKind(eventKind);&#xA;}&#xA;&#xA;const std::string Event::getCapsuleInstance() const {&#xA;    return this->capsuleInstance;&#xA;}&#xA;&#xA;void Event::setCapsuleInstance(const std::string capsuleInstance) {&#xA;    this->capsuleInstance = capsuleInstance;&#xA;}&#xA;&#xA;const std::string Event::getSourceName() const {&#xA;    return this->sourceName;&#xA;}&#xA;&#xA;void Event::setSourceName(const std::string sourceName) {&#xA;    this->sourceName = sourceName;&#xA;}&#xA;&#xA;const Event::EventSource Event::getEventSource() const {&#xA;    return this->eventSource;&#xA;}&#xA;&#xA;void Event::setEventSource(const Event::EventSource source) {&#xA;    this->eventSource = source;&#xA;}&#xA;&#xA;const Event::EventKind Event::getEventKind() const {&#xA;    return this->eventKind;&#xA;}&#xA;&#xA;void Event::setEventKind(const Event::EventKind kind) {&#xA;    this->eventKind = kind;&#xA;}&#xA;&#xA;const long Event::getSeconds() const {&#xA;    return this->seconds;&#xA;}&#xA;&#xA;const long Event::getNanoseconds() const {&#xA;    return this->nanoseconds;&#xA;}&#xA;&#xA;void Event::setTimestamp() {&#xA;&#xA;    long seconds, nanoseconds;&#xA;&#xA;    struct timeval tp;&#xA;    gettimeofday(&amp;tp, NULL);&#xA;&#xA;    seconds = tp.tv_sec;&#xA;    nanoseconds = tp.tv_usec * 1000;&#xA;&#xA;    this->setTimestamp(seconds, nanoseconds);&#xA;&#xA;}&#xA;&#xA;void Event::setTimestamp(const long seconds, const long nanoseconds) {&#xA;    setSeconds(seconds);&#xA;    this->setNanoseconds(nanoseconds);&#xA;    this->seconds = seconds;&#xA;    this->nanoseconds = nanoseconds;&#xA;}&#xA;&#xA;void Event::setSeconds(const long seconds) {&#xA;    this->seconds = seconds;&#xA;}&#xA;void Event::setNanoseconds(const long nanoseconds) {&#xA;    this->nanoseconds = nanoseconds;&#xA;}&#xA;&#xA;const std::string Event::getEventId() const {&#xA;    return this->eventId;&#xA;}&#xA;&#xA;void Event::setEventId(const std::string eventId) {&#xA;    this->eventId = eventId;&#xA;}&#xA;&#xA;void Event::generateEventId() {&#xA;&#xA;    long seconds, nanoseconds;&#xA;&#xA;    struct timeval tp;&#xA;    gettimeofday(&amp;tp, NULL);&#xA;&#xA;    seconds = tp.tv_sec;&#xA;    nanoseconds = tp.tv_usec * 1000;&#xA;&#xA;    std::stringstream ss;&#xA;    int r;&#xA;    r=random();&#xA;&#xA;    ss &lt;&lt; seconds &lt;&lt; nanoseconds &lt;&lt; r;&#xA;    this->eventId = ss.str();&#xA;}&#xA;&#xA;const std::map&lt;std::string, std::string> Event::getParams() const {&#xA;        return params;&#xA;}&#xA;&#xA;const std::string Event::getParam(std::string key) const {&#xA;    bool n = this->params.count(key);&#xA;    return (n) ? this->params.at(key) : &quot;&quot;;&#xA;}&#xA;&#xA;void Event::setParams(const  std::map&lt;std::string, std::string> params) {&#xA;        this->params = params;&#xA;}&#xA;&#xA;void Event::setParam(const  std::string key, const std::string value) {&#xA;    if (key.length() >= 1)&#xA;        this->params[key] = value;&#xA;}&#xA;&#xA;void Event::setParam(const  std::string key, const int value) {&#xA;    std::stringstream v;&#xA;    v &lt;&lt; value;&#xA;    this->setParam(key, v.str());&#xA;}&#xA;&#xA;void Event::clearParams() {&#xA;    this->params.clear();&#xA;}&#xA;&#xA;const UMLRTObject_class UMLRTType_Event = &#xA;{&#xA;    UMLRTObjectInitialize&lt;Event>,&#xA;    UMLRTObjectCopy&lt;Event>,&#xA;    UMLRTObject_decode,&#xA;    UMLRTObject_encode,&#xA;    UMLRTObjectDestroy&lt;Event>,&#xA;    UMLRTObject_fprintf,&#xA;    &quot;Event&quot;,&#xA;    NULL,&#xA;    {&#xA;        sizeof( Event ),&#xA;        0,&#xA;        Event::fields&#xA;    },&#xA;    UMLRTOBJECTCLASS_DEFAULT_VERSION,&#xA;    UMLRTOBJECTCLASS_DEFAULT_BACKWARDS&#xA;};"/>
  <RTCppProperties:ArtifactProperties xmi:id="_qQuiUG4VEeeUNoAgRbC5hw" base_Artifact="_qQdct24VEeeUNoAgRbC5hw" includeFile="#include &quot;Method.hh&quot;&#xD;&#xA;#include &lt;string>&#xD;&#xA;#include &lt;stdlib.h>&#xD;&#xA;#include &lt;unistd.h>&#xD;&#xA;#include &lt;sys/types.h>&#xD;&#xA;#include &lt;sys/socket.h>&#xD;&#xA;#include &lt;netinet/in.h>&#xD;&#xA;#include &lt;arpa/inet.h>&#xD;&#xA;#include &lt;netdb.h>&#xD;&#xA;&#xD;&#xA;class Socket : public Method {&#xD;&#xA;&#xD;&#xA;    private:&#xD;&#xA;        int port;&#xD;&#xA;        std::string address;&#xD;&#xA;&#xD;&#xA;        fd_set master;    // master file descriptor list&#xD;&#xA;        fd_set read_fds;  // temp file descriptor list for select()&#xD;&#xA;        int fdmax;        // maximum file descriptor number&#xD;&#xA;&#xD;&#xA;        int listener;     // listening socket descriptor&#xD;&#xA;        struct sockaddr_storage remoteaddr; // client address&#xD;&#xA;        socklen_t addrlen;&#xD;&#xA;&#xD;&#xA;        char remoteIP[INET6_ADDRSTRLEN];&#xD;&#xA;&#xD;&#xA;        struct timeval tv;&#xD;&#xA;&#xD;&#xA;    public:&#xD;&#xA;        Socket();&#xD;&#xA;        virtual ~Socket();&#xD;&#xA;        virtual void configure(std::map&lt;std::string, std::string> configList);&#xD;&#xA;        virtual const bool canConnect() const;&#xD;&#xA;        virtual int establishConnection();&#xD;&#xA;        virtual void disconnect();&#xD;&#xA;        virtual void read();&#xD;&#xA;        virtual void sendData(std::string data);&#xD;&#xA;&#xD;&#xA;        const int getPort() const;&#xD;&#xA;        void setPort(const int port);&#xD;&#xA;&#xD;&#xA;        const std::string getAddress() const;&#xD;&#xA;        void setAddress(const std::string address);&#xD;&#xA;};&#xD;&#xA;" sourceFile="#include &lt;stdio.h>&#xD;&#xA;#include &lt;stdlib.h>&#xD;&#xA;#include &lt;string.h>&#xD;&#xA;#include &lt;unistd.h>&#xD;&#xA;#include &lt;sys/types.h>&#xD;&#xA;#include &lt;sys/socket.h>&#xD;&#xA;#include &lt;netinet/in.h>&#xD;&#xA;#include &lt;arpa/inet.h>&#xD;&#xA;#include &lt;netdb.h>&#xD;&#xA;#include &lt;sstream>&#xD;&#xA;&#xD;&#xA;// get sockaddr, IPv4 or IPv6:&#xD;&#xA;void *get_in_addr(struct sockaddr *sa)&#xD;&#xA;{&#xD;&#xA;    if (sa->sa_family == AF_INET) {&#xD;&#xA;        return &amp;(((struct sockaddr_in*)sa)->sin_addr);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    return &amp;(((struct sockaddr_in6*)sa)->sin6_addr);&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;Socket::Socket() : Method() {&#xD;&#xA;    this->setPort(8080);&#xD;&#xA;    this->setAddress(&quot;localhost&quot;);&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;Socket::~Socket() {&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;void Socket::configure(std::map&lt;std::string, std::string> configList) {&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    std::string port, address;&#xD;&#xA;    port = this->getConfig(configList, &quot;port&quot;);&#xD;&#xA;    address = this->getConfig(configList, &quot;address&quot;);&#xD;&#xA;&#xD;&#xA;    if (!port.empty())&#xD;&#xA;        this->setPort(atoi(port.c_str()));&#xD;&#xA;&#xD;&#xA;    if (!address.empty())&#xD;&#xA;        this->setAddress(address);&#xD;&#xA;&#xD;&#xA;    printf(&quot;address: %s, port: %d\n&quot;, getAddress().c_str(), getPort());&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;const bool Socket::canConnect() const {&#xD;&#xA;    return true;&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;int Socket::establishConnection() {&#xD;&#xA;&#xD;&#xA;    int rv, result = -1;&#xD;&#xA;    struct addrinfo hints, *ai, *p;&#xD;&#xA;    int yes = 1;   // for setsockopt&#xD;&#xA;&#xD;&#xA;&#x9;std::stringstream port;&#xD;&#xA;&#x9;port &lt;&lt; this->getPort();&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    tv.tv_sec = 0;&#xD;&#xA;    tv.tv_usec = 0;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    FD_ZERO(&amp;master);    // clear the master and temp sets&#xD;&#xA;    FD_ZERO(&amp;read_fds);&#xD;&#xA;&#xD;&#xA;    // get us a socket and bind it&#xD;&#xA;    memset(&amp;hints, 0, sizeof hints);&#xD;&#xA;    hints.ai_family = AF_UNSPEC;&#xD;&#xA;    hints.ai_socktype = SOCK_STREAM;&#xD;&#xA;    hints.ai_flags = AI_PASSIVE;&#xD;&#xA;    if ((rv = getaddrinfo(NULL, port.str().c_str(), &amp;hints, &amp;ai)) != 0) {&#xD;&#xA;        fprintf(stderr, &quot;selectserver: %s\n&quot;, gai_strerror(rv));&#xD;&#xA;        exit(1);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    for(p = ai; p != NULL; p = p->ai_next) {&#xD;&#xA;        listener = socket(p->ai_family, p->ai_socktype, p->ai_protocol);&#xD;&#xA;        if (listener &lt; 0) { &#xD;&#xA;            continue;&#xD;&#xA;        }&#xD;&#xA;        &#xD;&#xA;        // lose the pesky &quot;address already in use&quot; error message&#xD;&#xA;        setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &amp;yes, sizeof(int));&#xD;&#xA;&#xD;&#xA;        if (bind(listener, p->ai_addr, p->ai_addrlen) &lt; 0) {&#xD;&#xA;            close(listener);&#xD;&#xA;            continue;&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        break;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    // if we got here, it means we didn't get bound&#xD;&#xA;    if (p == NULL) {&#xD;&#xA;        fprintf(stderr, &quot;selectserver: failed to bind\n&quot;);&#xD;&#xA;        exit(2);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    freeaddrinfo(ai); // all done with this&#xD;&#xA;&#xD;&#xA;    // listen&#xD;&#xA;    if (listen(listener, 10) == -1) {&#xD;&#xA;        perror(&quot;listen&quot;);&#xD;&#xA;        exit(3);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    // add the listener to the master set&#xD;&#xA;    FD_SET(listener, &amp;master);&#xD;&#xA;&#xD;&#xA;    // keep track of the biggest file descriptor&#xD;&#xA;    fdmax = listener; // so far, it's this one&#xD;&#xA;&#xD;&#xA;    return result;&#xD;&#xA;&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;void Socket::disconnect() {&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;void Socket::read() {&#xD;&#xA;&#xD;&#xA;    // main loop&#xD;&#xA;    read_fds = master; // copy it&#xD;&#xA;    int rc = select(fdmax+1, &amp;read_fds, NULL, NULL, &amp;tv); &#xD;&#xA;    if (rc == -1) {&#xD;&#xA;        perror(&quot;select&quot;);&#xD;&#xA;        exit(4);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    tv.tv_sec = 0;&#xD;&#xA;    tv.tv_usec = 0;&#xD;&#xA;&#xD;&#xA;    if (rc == 0) {&#xD;&#xA;     //   printf(&quot;timeout\n&quot;);&#xD;&#xA;        return;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    int i = 0;&#xD;&#xA;&#xD;&#xA;    // run through the existing connections looking for data to read&#xD;&#xA;    for(i = 0; i &lt;= fdmax; i++) {&#xD;&#xA;        if (FD_ISSET(i, &amp;read_fds)) { // we got one!!&#xD;&#xA;            if (i == listener) {&#xD;&#xA;                // handle new connections&#xD;&#xA;                addrlen = sizeof remoteaddr;&#xD;&#xA;                int newfd = accept(listener,&#xD;&#xA;                    (struct sockaddr *)&amp;remoteaddr,&#xD;&#xA;                    &amp;addrlen);&#xD;&#xA;&#xD;&#xA;                char remoteIP[INET6_ADDRSTRLEN];&#xD;&#xA;&#xD;&#xA;                if (newfd == -1) {&#xD;&#xA;                    perror(&quot;accept&quot;);&#xD;&#xA;                } else {&#xD;&#xA;                    FD_SET(newfd, &amp;master); // add to master set&#xD;&#xA;                    if (newfd > fdmax) {    // keep track of the max&#xD;&#xA;                        fdmax = newfd;&#xD;&#xA;                    }&#xD;&#xA;                    printf(&quot;new connection from %s on &quot;&#xD;&#xA;                        &quot;socket %d\n&quot;,&#xD;&#xA;                        inet_ntop(remoteaddr.ss_family,&#xD;&#xA;                            get_in_addr((struct sockaddr*)&amp;remoteaddr),&#xD;&#xA;                            remoteIP, INET6_ADDRSTRLEN),&#xD;&#xA;                        newfd);&#xD;&#xA;                }&#xD;&#xA;            } else {&#xD;&#xA;                char buf[256];    // buffer for client data&#xD;&#xA;                int nbytes;&#xD;&#xA;                // handle data from a client&#xD;&#xA;                if ((nbytes = recv(i, buf, sizeof buf, 0)) &lt;= 0) {&#xD;&#xA;                    // got error or connection closed by client&#xD;&#xA;                    if (nbytes == 0) {&#xD;&#xA;                        // connection closed&#xD;&#xA;                        printf(&quot;socket %d hung up\n&quot;, i);&#xD;&#xA;                    } else {&#xD;&#xA;                        perror(&quot;recv&quot;);&#xD;&#xA;                    }&#xD;&#xA;                    close(i); // bye!&#xD;&#xA;                    FD_CLR(i, &amp;master); // remove from master set&#xD;&#xA;                } else {&#xD;&#xA;                //    printf(&quot;new data: %s\n&quot;, buf);&#xD;&#xA;                //    // we got some data from a client&#xD;&#xA;                //    int j = 0;&#xD;&#xA;                //    for(j = 0; j &lt;= fdmax; j++) {&#xD;&#xA;                //        // send to everyone!&#xD;&#xA;                //        if (FD_ISSET(j, &amp;master)) {&#xD;&#xA;                //            // except the listener and ourselves&#xD;&#xA;                //            if (j != listener &amp;&amp; j != i) {&#xD;&#xA;                //                if (send(j, buf, nbytes, 0) == -1) {&#xD;&#xA;                //                    perror(&quot;send&quot;);&#xD;&#xA;                //                }&#xD;&#xA;                //            }&#xD;&#xA;                //        }&#xD;&#xA;                //    }&#xD;&#xA;                }&#xD;&#xA;            } // END handle data from client&#xD;&#xA;        } // END got new incoming connection&#xD;&#xA;    } // END looping through file descriptors&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;void Socket::sendData(std::string data) {&#xD;&#xA;    int j = 0;&#xD;&#xA;    for(j = 0; j &lt;= fdmax; j++) {&#xD;&#xA;        // send to everyone&#xD;&#xA;        if (FD_ISSET(j, &amp;master)) {&#xD;&#xA;            // no exception&#xD;&#xA;            if (j != listener) {&#xD;&#xA;                if (write(j, data.c_str(), data.length()) == -1) {&#xD;&#xA;                //    perror(&quot;does not work\n&quot;);&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;const int Socket::getPort() const {&#xD;&#xA;    return this->port;&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;void Socket::setPort(const int port) {&#xD;&#xA;    this->port = port;&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;const std::string Socket::getAddress() const {&#xD;&#xA;    return this->address;&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;void Socket::setAddress(const std::string address) {&#xD;&#xA;    this->address = address;&#xD;&#xA;}"/>
  <RTCppProperties:PassiveClassProperties xmi:id="_qQvwcG4VEeeUNoAgRbC5hw" base_Class="_qQdcuG4VEeeUNoAgRbC5hw" generate="false"/>
  <RTCppProperties:ArtifactProperties xmi:id="_qQwXgG4VEeeUNoAgRbC5hw" base_Artifact="_qQdcuW4VEeeUNoAgRbC5hw" includeFile="#include &quot;Serializer.hh&quot;&#xA;#include &quot;Event.hh&quot;&#xA;#include &lt;string>&#xA;#include &lt;stdlib.h>&#xA;#include &lt;unistd.h>&#xA;&#xA;class Text : public Serializer {&#xA;&#xA;    private:&#xA;        std::string format;&#xA;&#xA;        // separators&#xA;        char separator;&#xA;        char paramSeparator;&#xA;        char keyValueSeparator;&#xA;&#xA;        std::vector&lt;std::string> fields;&#xA;        unsigned int fieldNumber;&#xA;        const std::vector&lt;std::string> split(const std::string data, const char separator) const;&#xA;&#xA;    protected:&#xA;        const std::string getField(const std::string field, const Event&amp; event) const;&#xA;        void setField(const std::string field, const std::string value, Event&amp; event) const;&#xA;&#xA;&#xA;    public:&#xA;        Text();&#xA;        virtual ~Text();&#xA;        virtual void configure(std::map&lt;std::string, std::string> configList);&#xA;        virtual const std::string serialize(const Event event) const;&#xA;        const std::string serializeParams(const Event event) const;&#xA;        virtual Event parse(const std::string data) const;&#xA;        void parseParameters(Event&amp; event, const std::string data) const;&#xA;        void setFormat(const std::string format);&#xA;        const std::string getFormat() const;&#xA;        void setSeparator(const char separator);&#xA;        void setParamSeparator(const char paramSeparator);&#xA;        void setKeyValueSeparator(const char keyValueSeparator);&#xA;};" sourceFile="#include &quot;Event.hh&quot;&#xA;#include &quot;umlrttimespec.hh&quot;&#xA;&#xA;#include &lt;string.h>&#xA;#include &lt;sstream>&#xA;#include &lt;iostream>&#xA;#include &lt;sstream>&#xA;#include &lt;stdio.h>&#xA;#include &lt;stdlib.h>&#xA;#include &lt;vector>&#xA;#include &lt;algorithm>&#xA;&#xA;Text::Text() : Serializer() {&#xA;    this->setSeparator('|');&#xA;    this->setParamSeparator(';');&#xA;    this->setKeyValueSeparator(':');&#xA;    this->setFormat(&quot;eventId|sourceName|eventSource|eventKind|seconds|nanoseconds|params&quot;);&#xA;}&#xA;&#xA;Text::~Text() {&#xA;}&#xA;&#xA;void Text::configure(std::map&lt;std::string, std::string> configList) {&#xA;    std::string separator, paramSeparator, keyValueSeparator, format;&#xA;&#xA;    separator = this->getConfig(configList, &quot;text.separator&quot;);&#xA;    paramSeparator = this->getConfig(configList, &quot;text.paramSeparator&quot;);&#xA;    keyValueSeparator = this->getConfig(configList, &quot;text.keyValueSeparator&quot;);&#xA;    format = this->getConfig(configList, &quot;text.format&quot;);&#xA;&#xA;    if (!separator.empty())&#xA;        this->setSeparator(separator[0]);&#xA;&#xA;    if (!paramSeparator.empty())&#xA;        this->setParamSeparator(paramSeparator[0]);&#xA;&#xA;    if (!keyValueSeparator.empty())&#xA;        this->setKeyValueSeparator(keyValueSeparator[0]);&#xA;&#xA;&#xA;    if (!format.empty())&#xA;        this->setFormat(format);&#xA;&#xA;}&#xA;&#xA;void Text::setFormat(const std::string format) {&#xA;    this->format = format;&#xA;    std::vector&lt;std::string> v = this->split(format, this->separator);&#xA;&#xA;    if (!v.size())&#xA;        return;&#xA;&#xA;    this->fields.clear();&#xA;    this->fields = v;&#xA;    this->fieldNumber = this->fields.size();&#xA;}&#xA;&#xA;const std::string Text::getFormat() const {&#xA;    return this->format;&#xA;}&#xA;&#xA;void Text::setSeparator(const char separator) {&#xA;    this->separator = separator;&#xA;}&#xA;&#xA;void Text::setParamSeparator(const char paramSeparator) {&#xA;    this->paramSeparator = paramSeparator;&#xA;}&#xA;&#xA;void Text::setKeyValueSeparator(const char keyValueSeparator) {&#xA;    this->keyValueSeparator = keyValueSeparator;&#xA;}&#xA;&#xA;const std::string Text::serialize(Event event) const {&#xA;    &#xA;    char fieldSeparator = this->separator;&#xA;&#xA;    // results&#xA;    std::stringstream out;&#xA;&#xA;    std::vector&lt;std::string>::iterator it1;&#xA;    std::vector&lt;std::string> v = this->fields;&#xA;&#xA;    for (it1 = v.begin() ; it1 != v.end(); ++it1) {&#xA;        std::string field = *it1;&#xA;        std::transform(field.begin(), field.end(), field.begin(), ::tolower);&#xA;        out &lt;&lt; this->getField(field, event) &lt;&lt; fieldSeparator;&#xA;    }&#xA;&#xA;    return out.str();&#xA;}&#xA;&#xA;const std::string Text::serializeParams(Event event) const {&#xA;&#xA;    // results&#xA;    std::stringstream out;&#xA;&#xA;    // params&#xA;    std::map&lt;std::string,std::string>::const_iterator it2;&#xA;    std::map&lt;std::string,std::string> params = event.getParams();&#xA;&#xA;    if (params.empty())&#xA;        return out.str();&#xA;&#xA;&#xA;    it2 = params.begin();&#xA;    out &lt;&lt; it2->first &lt;&lt; this->keyValueSeparator &lt;&lt; it2->second;&#xA;    ++it2;&#xA;&#xA;    for (; it2 != params.end(); ++it2) {&#xA;        out &lt;&lt; this->paramSeparator &lt;&lt; it2->first &lt;&lt; this->keyValueSeparator &lt;&lt; it2->second;&#xA;    }&#xA;&#xA;    return out.str();&#xA;}&#xA; &#xA;Event Text::parse(const std::string data) const {&#xA;&#xA;    char fieldSeparator = this->separator;&#xA;&#xA;    std::vector&lt;std::string> values = this->split(data, fieldSeparator);&#xA;    Event event;&#xA;&#xA;    if (values.size() &lt; fieldNumber) {&#xA;        std::cout &lt;&lt; &quot;Error in parsing event stream, only &quot; &lt;&lt; values.size() &lt;&lt; &quot; are parsed \n&quot;;&#xA;        return event;&#xA;    }&#xA;&#xA;    std::vector&lt;std::string>::iterator it;&#xA;    std::vector&lt;std::string> v = this->fields;&#xA;    int i = 0;&#xA;&#xA;    for (it = v.begin() ; it != v.end(); ++it) {&#xA;        std::string field = *it;&#xA;        std::transform(field.begin(), field.end(), field.begin(), ::tolower);&#xA;        this->setField(field, values[i], event);&#xA;        i++;&#xA;    }&#xA;&#xA;    return event;&#xA;}&#xA;&#xA;void Text::parseParameters(Event&amp; event, const std::string data) const {&#xA;&#xA;    std::vector&lt;std::string> v = this->split(data, this->paramSeparator);&#xA;    std::string temp;&#xA;&#xA;    if (v.size() == 0)&#xA;        return;&#xA;&#xA;    event.clearParams();&#xA;&#xA;    for (unsigned i = 0; i &lt; v.size(); i++) {&#xA;&#xA;        std::string::size_type sepIndex = 0;&#xA;        std::string key, value;&#xA;&#xA;        temp = v[i];&#xA;&#xA;        sepIndex = temp.find(this->keyValueSeparator, 0);&#xA;        key = temp.substr(0, sepIndex);&#xA;        value = temp.substr(sepIndex + 1, temp.length());&#xA;&#xA;        event.setParam(key, value);&#xA;&#xA;    }&#xA;}&#xA;&#xA;const std::vector&lt;std::string> Text::split(const std::string data, const char separator) const {&#xA;&#xA;    std::vector&lt;std::string> v;&#xA;    std::string temp = &quot;&quot;;&#xA;    bool newField = false;&#xA;&#xA;    for (unsigned int i = 0; i &lt; data.length(); i++) {&#xA;        if (data[i] == separator) {&#xA;            newField = false;&#xA;            v.push_back(temp);&#xA;            temp = &quot;&quot;;&#xA;        }&#xA;        else {&#xA;            temp = temp + (data[i]);&#xA;            newField = true;&#xA;        }&#xA;    }&#xA;    if (newField)&#xA;        v.push_back(temp);&#xA;&#xA;    return v;&#xA;}&#xA;&#xA;// The functions below have to be overriden when extending the observer&#xA;const std::string Text::getField(const std::string field, const Event&amp; event) const {&#xA;&#xA;    std::stringstream ss; // for conversion purpose&#xA;&#xA;    if (field == &quot;eventid&quot;)&#xA;        return event.getEventId();&#xA;    else if (field == &quot;sourcename&quot;)&#xA;        return event.getSourceName();&#xA;    else if (field == &quot;eventsource&quot;) {&#xA;        ss &lt;&lt; event.getEventSource();&#xA;        return ss.str();&#xA;    }&#xA;    else if (field == &quot;eventkind&quot;) {&#xA;        ss &lt;&lt; event.getEventKind();&#xA;        return ss.str();&#xA;    }&#xA;    else if (field == &quot;seconds&quot;) {&#xA;        ss &lt;&lt; event.getSeconds();&#xA;        return ss.str();&#xA;    }&#xA;    else if (field == &quot;nanoseconds&quot;) {&#xA;        ss &lt;&lt; event.getNanoseconds();&#xA;        return ss.str();&#xA;    }&#xA;    else if (field == &quot;params&quot;) {&#xA;        return this->serializeParams(event);&#xA;    }&#xA;&#xA;    return &quot;&quot;;&#xA;}&#xA;&#xA;void Text::setField(const std::string field, const std::string value, Event&amp; event) const {&#xA;&#xA;    std::stringstream ss; // for conversion purpose&#xA;&#xA;    if (field == &quot;eventid&quot;)&#xA;        event.setEventId(value);&#xA;    else if (field == &quot;sourcename&quot;)&#xA;        event.setSourceName(value);&#xA;    else if (field == &quot;eventsource&quot;) {&#xA;        event.setEventSource((Event::EventSource)(atoi(value.c_str())));&#xA;    }&#xA;    else if (field == &quot;eventkind&quot;) {&#xA;        event.setEventKind((Event::EventKind)(atoi(value.c_str())));&#xA;    }&#xA;    else if (field == &quot;seconds&quot;) {&#xA;        event.setSeconds(atol(value.c_str()));&#xA;    }&#xA;    else if (field == &quot;nanoseconds&quot;) {&#xA;        event.setNanoseconds(atol(value.c_str()));&#xA;    }&#xA;    else if (field == &quot;params&quot;) {&#xA;        this->parseParameters(event, value);&#xA;    }&#xA;}&#xA;"/>
  <RTCppProperties:PassiveClassProperties xmi:id="_qQw-kG4VEeeUNoAgRbC5hw" base_Class="_qQdcum4VEeeUNoAgRbC5hw" generate="false"/>
  <RTCppProperties:PassiveClassProperties xmi:id="_qQxloG4VEeeUNoAgRbC5hw" base_Class="_qQdcu24VEeeUNoAgRbC5hw" generate="false"/>
  <RTCppProperties:PassiveClassProperties xmi:id="_qQyMsG4VEeeUNoAgRbC5hw" base_Class="_qQdcvG4VEeeUNoAgRbC5hw" generate="false"/>
  <RTCppProperties:ArtifactProperties xmi:id="_qQyzwG4VEeeUNoAgRbC5hw" base_Artifact="_qQdcvW4VEeeUNoAgRbC5hw" includeFile="#include &quot;Method.hh&quot;&#xD;&#xA;#include &lt;string>&#xD;&#xA;#include &lt;stdlib.h>&#xD;&#xA;#include &lt;unistd.h>&#xD;&#xA;#include &lt;sys/types.h>&#xD;&#xA;#include &lt;sys/socket.h>&#xD;&#xA;#include &lt;netinet/in.h>&#xD;&#xA;#include &lt;arpa/inet.h>&#xD;&#xA;#include &lt;netdb.h>&#xD;&#xA;&#xD;&#xA;class ClientSocket : public Method {&#xD;&#xA;&#xD;&#xA;private:&#xD;&#xA;std::string address;&#xD;&#xA;int port;&#xD;&#xA;int sockfd, portno, n;&#xD;&#xA;struct sockaddr_in serv_addr;&#xD;&#xA;struct hostent *server;&#xD;&#xA;&#xD;&#xA;char buffer[256];&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;public:&#xD;&#xA;ClientSocket();&#xD;&#xA;virtual ~ClientSocket();&#xD;&#xA;virtual void configure(std::map&lt;std::string, std::string> configList);&#xD;&#xA;virtual const bool canConnect() const;&#xD;&#xA;virtual int establishConnection();&#xD;&#xA;virtual void disconnect();&#xD;&#xA;virtual void read();&#xD;&#xA;virtual void sendData(std::string data);&#xD;&#xA;&#xD;&#xA;const int getPort() const;&#xD;&#xA;void setPort(const int port);&#xD;&#xA;&#xD;&#xA;const std::string getAddress() const;&#xD;&#xA;void setAddress(const std::string address);&#xD;&#xA;};" sourceFile="#include &lt;stdio.h>&#xD;&#xA;#include &lt;stdlib.h>&#xD;&#xA;#include &lt;string.h>&#xD;&#xA;#include &lt;unistd.h>&#xD;&#xA;#include &lt;sys/types.h>&#xD;&#xA;#include &lt;sys/socket.h>&#xD;&#xA;#include &lt;netinet/in.h>&#xD;&#xA;#include &lt;arpa/inet.h>&#xD;&#xA;#include &lt;netdb.h>&#xD;&#xA;#include &lt;sstream>&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;ClientSocket::ClientSocket() : Method() {&#xD;&#xA;this->setPort(8080);&#xD;&#xA;this->setAddress(&quot;localhost&quot;);&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;ClientSocket::~ClientSocket() {&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;void ClientSocket::configure(std::map&lt;std::string, std::string> configList) {&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;std::string port, address;&#xD;&#xA;port = this->getConfig(configList, &quot;port&quot;);&#xD;&#xA;address = this->getConfig(configList, &quot;address&quot;);&#xD;&#xA;&#xD;&#xA;if (!port.empty())&#xD;&#xA;this->setPort(atoi(port.c_str()));&#xD;&#xA;&#xD;&#xA;if (!address.empty())&#xD;&#xA;this->setAddress(address);&#xD;&#xA;&#xD;&#xA;printf(&quot;address: %s, port: %d\n&quot;, getAddress().c_str(), getPort());&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;const bool ClientSocket::canConnect() const {&#xD;&#xA;return true;&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;int ClientSocket::establishConnection() {&#xD;&#xA;&#xA;&#xD;&#xA;int result = -1;&#xD;&#xA;&#xD;&#xA;sockfd = socket(AF_INET, SOCK_STREAM, 0);&#xD;&#xA;if (sockfd &lt; 0) &#xD;&#xA;perror(&quot;ERROR opening socket&quot;);&#xD;&#xA;server = gethostbyname(this->getAddress().c_str());&#xD;&#xA;&#xD;&#xA;if (server == NULL) {&#xD;&#xA;perror(&quot;ERROR, no such host\n&quot;);&#xD;&#xA;exit(0);&#xD;&#xA;}&#xA;&#xD;&#xA;bzero((char *) &amp;serv_addr, sizeof(serv_addr));&#xD;&#xA;serv_addr.sin_family = AF_INET;&#xD;&#xA;bcopy((char *)server->h_addr, &#xD;&#xA;(char *)&amp;serv_addr.sin_addr.s_addr,&#xD;&#xA;server->h_length);&#xD;&#xA;serv_addr.sin_port = htons(this->getPort());&#xA;&#xA;&#xD;&#xA;if (connect(sockfd,(struct sockaddr *) &amp;serv_addr,sizeof(serv_addr)) &lt; 0) &#xD;&#xA;perror(&quot;ERROR connecting\n&quot;);&#xD;&#xA;&#xD;&#xA;return result;&#xD;&#xA;&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;void ClientSocket::disconnect() {&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;void ClientSocket::read() {&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;void ClientSocket::sendData(std::string data) {&#xD;&#xA;write(sockfd,data.c_str(),data.length());&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;const int ClientSocket::getPort() const {&#xD;&#xA;return this->port;&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;void ClientSocket::setPort(const int port) {&#xD;&#xA;this->port = port;&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;const std::string ClientSocket::getAddress() const {&#xD;&#xA;return this->address;&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;void ClientSocket::setAddress(const std::string address) {&#xD;&#xA;this->address = address;&#xD;&#xA;}"/>
  <UMLRealTime:RTPort xmi:id="_tj_p4G4VEeeUNoAgRbC5hw" isPublish="false" isWired="false" base_Port="_tj7YcG4VEeeUNoAgRbC5hw"/>
  <UMLRealTime:RTPort xmi:id="_zHypoG4VEeeUNoAgRbC5hw" isNotification="false" isPublish="false" isWired="false" registration="Automatic" registrationOverride="" base_Port="_zHyCkG4VEeeUNoAgRbC5hw"/>
  <UMLRealTime:RTPort xmi:id="_z_BzoG4VEeeUNoAgRbC5hw" isNotification="false" isPublish="false" isWired="false" registration="Automatic" registrationOverride="" base_Port="_z_BMkG4VEeeUNoAgRbC5hw"/>
  <UMLRealTime:RTPort xmi:id="_0vVPMG4VEeeUNoAgRbC5hw" isNotification="false" isPublish="false" isWired="false" registration="Automatic" registrationOverride="" base_Port="_0vUoIG4VEeeUNoAgRbC5hw"/>
  <UMLRealTime:CapsulePart xmi:id="_-G2_QG4VEeeUNoAgRbC5hw" base_Property="_-GxfsG4VEeeUNoAgRbC5hw"/>
</xmi:XMI>
